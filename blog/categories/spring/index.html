<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Category: spring | OOPcoder</title>
  
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  
  <meta name="theme-color" content="#FFFFFF">
  <meta name="msapplication-TileColor" content="#1BC3FB">
  <meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/browserconfig.xml">
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  
  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  <link rel="icon" type="image/x-icon" sizes="32x32" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/favicon-32x32.png">
  <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/apple-touch-icon.png">
  <link rel="mask-icon" color="#1BC3FB" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/safari-pinned-tab.svg">
  <link rel="manifest" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/site.webmanifest">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <h1 class='title'>OOPcoder</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="https://github.com/lanboys1225"
            
            
            id="https:github.comlanboys1225">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;项目
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          OOPcoder
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;首页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://github.com/lanboys1225"
                
                
                id="https:github.comlanboys1225">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/"
                
                  rel="nofollow"
                
                
                id="https:xaoxuu.comwikimaterial-x">
								<i class='fas fa-book fa-fw'></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/12/12/spring-bean-instantiate-1/">
      Spring容器源码解析之Bean的实例化(一)
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://me.oopcoder.cn" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>lanboys1225</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-12-12</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/spring/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>spring</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <blockquote>
<p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p>
</blockquote>
<ul>
<li><a href="https://me.oopcoder.cn/2019/10/18/spring-resource-load/">Spring容器加载过程源码解析之Resource定位加载</a></li>
<li><a href="https://me.oopcoder.cn/2019/10/21/spring-resource-parse/">Spring容器加载过程源码解析之Resource解析流程</a></li>
<li><a href="https://me.oopcoder.cn/2019/10/27/spring-resource-parse-default-element/index.html">Spring容器加载过程源码解析之默认标签解析</a></li>
<li><a href="https://me.oopcoder.cn/2019/11/01/spring-resource-parse-custom-element/">Spring容器加载过程源码解析之自定义标签解析</a></li>
</ul>
<p>经过上面【Spring加载过程源码解析系列】的学习，我们完成了 <code>Bean</code>配置的解析和注册过程，容器中存在的是 <code>Bean</code> 对应的 <code>BeanDefinition</code>,<code>Bean</code>并没有完成实例化，接下来我们看看到底是怎么实例化的。</p>
<p>开门见山，<code>Bean</code> 的实例化是在使用前完成的，即在方法 <code>getBean</code> 中 实例化。</p>
<h5 id="1-getBean"><a href="#1-getBean" class="headerlink" title="1. getBean"></a>1. getBean</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">    return doGetBean(name, null, null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">    return doGetBean(name, requiredType, null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object getBean(String name, Object... args) throws BeansException &#123;</span><br><span class="line">    return doGetBean(name, null, args, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123;</span><br><span class="line">    return doGetBean(name, requiredType, args, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四个重载方法都指向了 <code>doGetBean</code> 方法</p>
<h5 id="2-doGetBean"><a href="#2-doGetBean" class="headerlink" title="2. doGetBean"></a>2. doGetBean</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; T doGetBean(final String name, final Class&lt;T&gt; requiredType, final Object[] args, </span><br><span class="line">        boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">    </span><br><span class="line">    // 将传入的name转换为实际的beanName, a -&gt; a ; &amp;a -&gt; a; </span><br><span class="line">    // 如果该bean类型class是FactoryBean, 无论是getBean(a),还是getBean(&amp;a),</span><br><span class="line">    // 都是先实例化FactoryBean, 然后再返回实际需要的bean</span><br><span class="line">    final String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">    // 先从缓存中获取单例</span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    // 缓存中存在单例，并且 args 为空(因为只有prototype才能带参数 args)，才进入 getObjectForBeanInstance</span><br><span class="line">    if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">        // 获取实际需要的bean, sharedInstance 可能为 FactoryBean</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 检查是否为 当前线程正在创建的prototype 实例</span><br><span class="line">        if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查是否存在当前beanFactory中，不存在则去父工厂(存在的话)中找</span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            if (args != null) &#123;</span><br><span class="line">                return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 检查是否只是为了类型检查而创建bean, 不是的话将beanName添加到已创建bean容器中</span><br><span class="line">        // removeSingletonIfCreatedForTypeCheckOnly() 方法可移除只用来检查类型创建的bean</span><br><span class="line">        if (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取合并后的根 BeanDefinition，BeanDefintiton 根类一样具有继承关系</span><br><span class="line">        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">        // 将依赖的bean提前创建</span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        if (dependsOn != null) &#123;</span><br><span class="line">            for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                getBean(dependsOnBean);</span><br><span class="line">                // 注册依赖 bean</span><br><span class="line">                registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建单例实例</span><br><span class="line">        if (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, new ObjectFactory() &#123;</span><br><span class="line">                public Object getObject() throws BeansException &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 创建bean</span><br><span class="line">                        return createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; catch (BeansException ex) &#123;</span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        throw ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        //  创建原型实例</span><br><span class="line">        else if (mbd.isPrototype()) &#123;</span><br><span class="line">            // It&apos;s a prototype -&gt; create a new instance.</span><br><span class="line">            Object prototypeInstance = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                beforePrototypeCreation(beanName);</span><br><span class="line">                prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        //  创建自定义Scope实例, CustomScopeConfigurer / SimpleThreadScope</span><br><span class="line">        else &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">            if (scope == null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Object scopedInstance = scope.get(beanName, new ObjectFactory() &#123;</span><br><span class="line">                    public Object getObject() throws BeansException &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            return createBean(beanName, mbd, args);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IllegalStateException ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查获取到的bean与参数 requiredType 是否匹配</span><br><span class="line">    if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    return (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>doGetBean</code> 方法里面调用了几个比较重要的方法：</p>
<ul>
<li>getSingleton(String beanName);</li>
<li>getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd);</li>
<li>getMergedLocalBeanDefinition(String beanName);</li>
<li>getSingleton(String beanName, ObjectFactory singletonFactory);</li>
<li>createBean(String beanName, RootBeanDefinition mbd, Object[] args)。</li>
</ul>
<h5 id="3-getSingleton"><a href="#3-getSingleton" class="headerlink" title="3. getSingleton"></a>3. getSingleton</h5><p>我们先看看<code>getSingleton(String beanName, ObjectFactory singletonFactory)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Object getSingleton(String beanName, ObjectFactory singletonFactory) &#123;</span><br><span class="line">    synchronized (this.singletonObjects) &#123;</span><br><span class="line">        // 先从缓存中获取</span><br><span class="line">        Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">        if (singletonObject == null) &#123;</span><br><span class="line">            // 标记当前 beanName 正在创建</span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 调用 createBean()</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">            &#125; catch (BeanCreationException ex) &#123;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            // 添加到缓存中</span><br><span class="line">            addSingleton(beanName, singletonObject);</span><br><span class="line">        &#125;</span><br><span class="line">        return (singletonObject != NULL_OBJECT ? singletonObject : null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-createBean"><a href="#4-createBean" class="headerlink" title="4. createBean"></a>4. createBean</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123;</span><br><span class="line">    // Make sure bean class is actually resolved at this point.</span><br><span class="line">    // 将bean标签中class属性解析为Class类</span><br><span class="line">    resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    // 检查 MethodOverrides, 主要是检查 MethodOverride 里面的 methodName 是否存在，或者是否重载</span><br><span class="line">    try &#123;</span><br><span class="line">        mbd.prepareMethodOverrides();</span><br><span class="line">    &#125; catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">        // 给BeanPostProcessors机会返回一个代理bean, 替代掉目标bean </span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbd);</span><br><span class="line">        if (bean != null) &#123;</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException();</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建 bean</span><br><span class="line">    Object beanInstance = doCreateBean(beanName, mbd, args);</span><br><span class="line">    return beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-doCreateBean"><a href="#5-doCreateBean" class="headerlink" title="5. doCreateBean"></a>5. doCreateBean</h5><p>看看真正创建Bean的方法 doCreateBean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</span><br><span class="line">    // Instantiate the bean.</span><br><span class="line">    BeanWrapper instanceWrapper = null;</span><br><span class="line">    // 如果是单例，看是否存在FactoryBean缓存，这个缓存主要是在调用 isTypeMatch() 或 getType() 检查类型匹配或者获取类型后缓存起来的</span><br><span class="line">    if (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    if (instanceWrapper == null) &#123;</span><br><span class="line">        // 创建Bean实例，并返回Bean的包装实例</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">    Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line"></span><br><span class="line">    // Allow post-processors to modify the merged bean definition.</span><br><span class="line">    synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">        if (!mbd.postProcessed) &#123;</span><br><span class="line">            // post-processors 可以在此修改definition</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            mbd.postProcessed = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">    // even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">    boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    // 这里的目的就是解决循环依赖的问题</span><br><span class="line">    if (earlySingletonExposure) &#123;</span><br><span class="line">        addSingletonFactory(beanName, new ObjectFactory() &#123;</span><br><span class="line">            public Object getObject() throws BeansException &#123;</span><br><span class="line">                return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Initialize the bean instance.</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 将xml文件配置的各种属性值填充到Bean中</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        // 初始化bean, 顺序：postProcessBeforeInitialization() -&gt; afterPropertiesSet() -&gt; </span><br><span class="line">        // 自定义的 init-method -&gt; postProcessAfterInitialization()</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125; catch (Throwable ex) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean实例化的大致流程基本上就是这样了，上面提到的一些重要方法这里还没具体看，我们下次再来分析一波。</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/spring/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>spring</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/01/spring-resource-parse-custom-element/">
      Spring容器加载过程源码解析之自定义标签解析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://me.oopcoder.cn" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>lanboys1225</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-01</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/spring/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>spring</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <blockquote>
<p>在上文 <a href="https://me.oopcoder.cn/2019/10/27/spring-resource-parse-default-element/index.html">Spring容器加载过程源码解析之默认标签解析</a> 中，我们学习了默认标签的解析，今天我们来看看自定义的标签和属性是如何解析的。</p>
</blockquote>
<blockquote>
<p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p>
</blockquote>
<h5 id="1-常用的自定义标签和属性"><a href="#1-常用的自定义标签和属性" class="headerlink" title="1. 常用的自定义标签和属性"></a>1. 常用的自定义标签和属性</h5><p>自定义标签：<code>&lt;context:annotation-config/&gt;</code>, <code>&lt;context:component-scan base-package=&quot;com.xx.xx&quot;/&gt;</code>, <code>&lt;mvc:annotation-driven&gt;</code>, <code>&lt;aop:aspectj-autoproxy/&gt;</code>等等都是自定义的标签；</p>
<p>自定义属性见得比较少，不过也有，如带 “p” 前缀的属性，是在<code>spring-beans</code>jar包中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">						http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">						http://www.springframework.org/schema/context</span><br><span class="line">						http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    &lt;!--    启用注解    --&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;!--    设置扫描的包    --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;hello&quot; class=&quot;com.xxx.Hello&quot;/&gt;</span><br><span class="line">    &lt;!-- p:hello-ref 定义 HelloWorld 属性 hello，有后缀 -ref 表示bean的id --&gt;</span><br><span class="line">    &lt;!-- p:world 定义 HelloWorld 属性 world 的值 --&gt;</span><br><span class="line">    &lt;!-- p:world 会与下方的 property world 冲突 --&gt;</span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;com.xxx.HelloWorld&quot;</span><br><span class="line">          p:hello-ref=&quot;hello&quot; p:world=&quot;world-value-p&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;world&quot; value=&quot;world-value&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-parseCustomElement分析"><a href="#2-parseCustomElement分析" class="headerlink" title="2. parseCustomElement分析"></a>2. parseCustomElement分析</h5><p>我们先从自定义标签解析方法的起始位置 <code>DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</code> 看起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // 判断是否为默认命名空间下的标签</span><br><span class="line">    if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123;</span><br><span class="line">        // 循环遍历 解析默认标签</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            if (node instanceof Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                String namespaceUri = delegate.getNamespaceURI(ele);</span><br><span class="line">                // 判断是否为默认命名空间下的标签</span><br><span class="line">                if (delegate.isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">                    // 默认标签解析方法</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 自定义标签解析方法</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 自定义标签解析方法</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>委托给了<code>BeanDefinitionParserDelegate#parseCustomElement</code>进行解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parseCustomElement(Element ele) &#123;</span><br><span class="line">    return parseCustomElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;</span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    // 根据命名空间获取对应的处理器 (命名空间处理解析器,下面会分析)</span><br><span class="line">    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    if (handler == null) &#123;</span><br><span class="line">        error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理器进行解析</span><br><span class="line">    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-NamespaceHandler分析"><a href="#3-NamespaceHandler分析" class="headerlink" title="3. NamespaceHandler分析"></a>3. NamespaceHandler分析</h5><p><img src="https://pic.superbed.cn/item/5dba48a6bd461d945a7503e6.png" alt></p>
<p>结合上面类图，查看源码发现，命名空间处理器的主要逻辑是放在其子类<code>NamespaceHandlerSupport</code>中，而<code>NamespaceHandlerSupport</code>的子类主要是实现<code>init</code>方法，在里面注册该命名空间下标签对应的解析器，如<code>ContextNamespaceHandler</code>的<code>init</code>方法，一个标签对应一个解析器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">    // 注册解析器 BeanDefinitionParser</span><br><span class="line">    registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NamespaceHandler</code>调用解析器进行解析的方法是 <code>parse</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    // 查找对应的解析器进行解析</span><br><span class="line">    return findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    // 根据标签名获取解析器</span><br><span class="line">    BeanDefinitionParser parser = this.parsers.get(localName);</span><br><span class="line">    if (parser == null) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">                &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element);</span><br><span class="line">    &#125;</span><br><span class="line">    return parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-BeanDefinitionParser分析"><a href="#4-BeanDefinitionParser分析" class="headerlink" title="4. BeanDefinitionParser分析"></a>4. BeanDefinitionParser分析</h5><p>我们拿常用的<code>context:component-scan</code>标签解析器看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    // 获取 base-package 值</span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE),</span><br><span class="line">            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">    // Actually scan for bean definitions and register them.</span><br><span class="line">    // 扫描并注册</span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同标签的具体解析逻辑就在<code>parse</code>方法中了。</p>
<h5 id="5-NamespaceHandler的注册"><a href="#5-NamespaceHandler的注册" class="headerlink" title="5. NamespaceHandler的注册"></a>5. NamespaceHandler的注册</h5><p>我们在前面提过的命名空间处理解析器，用来解析命名空间对应的处理器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br></pre></td></tr></table></figure>

<p>它的默认实现是<code>DefaultNamespaceHandlerResolver</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public NamespaceHandler resolve(String namespaceUri) &#123;</span><br><span class="line">    // 获取所有处理器</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">    Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">    if (handlerOrClassName == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123;</span><br><span class="line">        return (NamespaceHandler) handlerOrClassName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String className = (String) handlerOrClassName;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader);</span><br><span class="line">            if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">                throw new FatalBeanException(&quot;.....&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 实例化处理器</span><br><span class="line">            NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">            // 初始化处理器，里面就是注册解析器</span><br><span class="line">            namespaceHandler.init();</span><br><span class="line">            handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">            return namespaceHandler;</span><br><span class="line">        &#125;</span><br><span class="line">        //..........此处省略部分源码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Map&lt;String, Object&gt; getHandlerMappings() &#123;</span><br><span class="line">    if (this.handlerMappings == null) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (this.handlerMappings == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 加载 META-INF/spring.handlers 属性文件</span><br><span class="line">                    // this.handlerMappingsLocation = &quot;META-INF/spring.handlers&quot;</span><br><span class="line">                    Properties mappings = PropertiesLoaderUtils</span><br><span class="line">                            .loadAllProperties(this.handlerMappingsLocation, this.classLoader);</span><br><span class="line"></span><br><span class="line">                    Map&lt;String, Object&gt; handlerMappings = new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line">                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line">                    this.handlerMappings = handlerMappings;</span><br><span class="line">                &#125;</span><br><span class="line">                //..........此处省略部分源码</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中出现了<code>&quot;META-INF/spring.handlers&quot;</code>这么一个文件，打开<code>spring-beans</code>,<code>spring-context</code>jar包下该文件，有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring-beans下</span><br><span class="line"></span><br><span class="line">http\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br><span class="line"></span><br><span class="line">spring-context下</span><br><span class="line"></span><br><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br></pre></td></tr></table></figure>

<p>我们看到命名空间 <code>http\://www.springframework.org/schema/context</code>的处理器<code>org.springframework.context.config.ContextNamespaceHandler</code>的对应关系就是在这里确定的。</p>
<h5 id="6-自定义属性解析"><a href="#6-自定义属性解析" class="headerlink" title="6. 自定义属性解析"></a>6. 自定义属性解析</h5><p>我们来回顾下 <code>BeanDefinitionParserDelegate#parseBeanDefinitionElement</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // bean标签比较复杂，委托给了BeanDefinitionParserDelegate进行解析，返回封装了含 BeanDefinition，beanName，aliases 的BeanDefinitionHolder</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    if (bdHolder != null) &#123;</span><br><span class="line">        // 解析自定义属性或标签</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        try &#123;</span><br><span class="line">            // Register the final decorated instance.</span><br><span class="line">            // 注册到 BeanDefinitionRegistry，也就是DefaultListableBeanFactory中的 beanDefinitionMap 中</span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;catch (BeanDefinitionStoreException ex) &#123;&#125;</span><br><span class="line">        // Send registration event. 发送bean注册事件</span><br><span class="line">        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>delegate.decorateBeanDefinitionIfRequired(ele, bdHolder)</code>就是自定义属性的入口了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder) &#123;</span><br><span class="line">    return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder decorateBeanDefinitionIfRequired(</span><br><span class="line">        Element ele, BeanDefinitionHolder definitionHolder, BeanDefinition containingBd) &#123;</span><br><span class="line">    BeanDefinitionHolder finalDefinition = definitionHolder;</span><br><span class="line">    // Decorate based on custom attributes first.</span><br><span class="line">    NamedNodeMap attributes = ele.getAttributes();</span><br><span class="line">    for (int i = 0; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">        Node node = attributes.item(i);</span><br><span class="line">        // 遍历属性</span><br><span class="line">        finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">    &#125;</span><br><span class="line">    // Decorate based on custom nested elements.</span><br><span class="line">    NodeList children = ele.getChildNodes();</span><br><span class="line">    for (int i = 0; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">        Node node = children.item(i);</span><br><span class="line">        if (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">            // 遍历子标签</span><br><span class="line">            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return finalDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private BeanDefinitionHolder decorateIfRequired(</span><br><span class="line">        Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) &#123;</span><br><span class="line">    String namespaceUri = getNamespaceURI(node);</span><br><span class="line">    if (!isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">        // 这里跟前面的逻辑类似，就不重复讲了</span><br><span class="line">        NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        if (handler != null) &#123;</span><br><span class="line">            return handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">        &#125;</span><br><span class="line">        //..........此处省略部分源码</span><br><span class="line">    &#125;</span><br><span class="line">    return originalDef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看装饰方法<code>NamespaceHandlerSupport#decorate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder decorate(</span><br><span class="line">        Node node, BeanDefinitionHolder definition, ParserContext parserContext) &#123;</span><br><span class="line"></span><br><span class="line">    return findDecoratorForNode(node, parserContext).decorate(node, definition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private BeanDefinitionDecorator findDecoratorForNode(Node node, ParserContext parserContext) &#123;</span><br><span class="line">    BeanDefinitionDecorator decorator = null;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(node);</span><br><span class="line">    if (node instanceof Element) &#123;</span><br><span class="line">        // 获取元素装饰器</span><br><span class="line">        decorator = this.decorators.get(localName);</span><br><span class="line">    &#125; else if (node instanceof Attr) &#123;</span><br><span class="line">        // 获取属性装饰器</span><br><span class="line">        decorator = this.attributeDecorators.get(localName);</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    return decorator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看另外一个处理器 <code>SimplePropertyNamespaceHandler</code>的实现，这个处理器对应的是带 “p” 前缀的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) &#123;</span><br><span class="line">    if (node instanceof Attr) &#123;</span><br><span class="line">        Attr attr = (Attr) node;</span><br><span class="line">        String propertyName = parserContext.getDelegate().getLocalName(attr);</span><br><span class="line">        String propertyValue = attr.getValue();</span><br><span class="line">        MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();</span><br><span class="line">        // 判断是否已经存在，默认标签优先解析</span><br><span class="line">        if (pvs.contains(propertyName)) &#123;</span><br><span class="line">            parserContext.getReaderContext().error(&quot;Property &apos;&quot; + propertyName + &quot;&apos; is already defined using &quot; +</span><br><span class="line">                    &quot;both &lt;property&gt; and inline syntax. Only one approach may be used per property.&quot;, attr);</span><br><span class="line">        &#125;</span><br><span class="line">        // 以 &quot;-ref&quot; 结尾，表示的是值为beanName，非具体值</span><br><span class="line">        if (propertyName.endsWith(&quot;-ref&quot;)) &#123;</span><br><span class="line">            propertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());</span><br><span class="line">            pvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 将值添加到definition中</span><br><span class="line">            pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信大家看到这里应该明白自定义的标签或属性是怎么解析的了，大家可以尝试去定义一下自己的属性标签，这里就不带大家去实践了。</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/spring/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>spring</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/10/27/spring-resource-parse-default-element/">
      Spring容器加载过程源码解析之默认标签解析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://me.oopcoder.cn" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>lanboys1225</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-10-27</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/spring/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>spring</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <blockquote>
<p>在上文 <a href="https://me.oopcoder.cn/2019/10/21/spring-resource-parse/">Spring容器加载过程源码解析之Resource解析流程</a> 中，我们已经了解了整个解析流程，今天我们来具体分析下默认标签的解析。</p>
</blockquote>
<blockquote>
<p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p>
</blockquote>
<h5 id="1-什么是默认标签和自定义标签"><a href="#1-什么是默认标签和自定义标签" class="headerlink" title="1.什么是默认标签和自定义标签"></a>1.什么是默认标签和自定义标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // 判断是否为默认命名空间下的标签</span><br><span class="line">    if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123;</span><br><span class="line">        // 循环遍历 解析默认标签</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            if (node instanceof Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                String namespaceUri = delegate.getNamespaceURI(ele);</span><br><span class="line">                // 判断是否为默认命名空间下的标签</span><br><span class="line">                if (delegate.isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">                    // 默认标签解析方法</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 自定义标签解析方法</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 自定义标签解析方法</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断是否为默认命名空间下的标签</span><br><span class="line">public boolean isDefaultNamespace(String namespaceUri) &#123;</span><br><span class="line">	return (!StringUtils.hasLength(namespaceUri) || &quot;http://www.springframework.org/schema/beans&quot;.equals(namespaceUri));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        // 解析 import 标签</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        // 解析 alias 标签</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        // 解析 bean 标签</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>isDefaultNamespace()</code> 方法可以看出，在命名空间 <code>http://www.springframework.org/schema/beans</code> 下面定义的标签就是我们所说的默认标签，比如顶级标签 <code>beans</code>, 以及下面的 <code>bean</code>,<code>import</code>,<code>alias</code>等等其他标签。</p>
<p>而不在默认命名空间下的标签就是自定义标签了，比如我们最常见的带 <code>context</code> 前缀的标签：<code>&lt;context:annotation-config/&gt;</code>,<code>&lt;context:component-scan base-package=&quot;com.xx.xx&quot;/&gt;</code>等。</p>
<h5 id="2-bean-标签解析方法-processBeanDefinition"><a href="#2-bean-标签解析方法-processBeanDefinition" class="headerlink" title="2.bean 标签解析方法 processBeanDefinition"></a>2.bean 标签解析方法 processBeanDefinition</h5><p>委托给了<code>BeanDefinitionParserDelegate#parseBeanDefinitionElement</code>进行解析，解析完成后再进行注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // bean标签比较复杂，委托给了BeanDefinitionParserDelegate进行解析，返回封装了含 BeanDefinition，beanName，aliases 的BeanDefinitionHolder</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    if (bdHolder != null) &#123;</span><br><span class="line">        // 解析自定义属性或标签</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        try &#123;</span><br><span class="line">            // Register the final decorated instance.</span><br><span class="line">            // 注册到 BeanDefinitionRegistry，也就是DefaultListableBeanFactory中的 beanDefinitionMap 中</span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;catch (BeanDefinitionStoreException ex) &#123;&#125;</span><br><span class="line">        // Send registration event. 发送bean注册事件</span><br><span class="line">        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下看看代理类 <code>BeanDefinitionParserDelegate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    // beans 标签下的 bean, containingBean 为空</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">    // 获取属性 id 值，用作 beanName</span><br><span class="line">    String id = ele.getAttribute(&quot;id&quot;);</span><br><span class="line">    // 获取属性 name 值，用作别名, 多个别名可用‘，’或‘；’分割开来</span><br><span class="line">    String nameAttr = ele.getAttribute(&quot;name&quot;);</span><br><span class="line">    // 分割多个别名</span><br><span class="line">    List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class="line">    if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    // 属性id值作为 bean 的名称</span><br><span class="line">    String beanName = id;</span><br><span class="line">    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        // 如果未定义id, 则将 第一个别名作为 beanName</span><br><span class="line">        beanName = aliases.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">    // beans 标签下的bean, 需要检查beanName和aliases的在当前xml配置文件中的唯一性</span><br><span class="line">    // bean 标签中嵌套的 bean 不需要检查</span><br><span class="line">    if (containingBean == null) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    // 解析标签的具体操作</span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    if (beanDefinition != null) &#123;</span><br><span class="line">        // 下面主要是没有定义 beanName 时，名字自动生成的逻辑</span><br><span class="line">        if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (containingBean != null) &#123;</span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                            beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"></span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    if (beanClassName != null &amp;&amp;</span><br><span class="line">                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //..........此处省略部分源码</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        // 返回 holder</span><br><span class="line">        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这部分主要是处理名字和别名的逻辑，下面看下解析的具体操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">        Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line">    this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = null;</span><br><span class="line">    // 解析 class 属性</span><br><span class="line">    if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        String parent = null;</span><br><span class="line">        // 解析 parent 属性</span><br><span class="line">        if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建GenericBeanDefinition实例</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">        // 解析其他属性 </span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">        // 解析meta标签</span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        // 解析lookup-method标签</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        // 解析replaced-method标签</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        // 解析constructor-arg标签</span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        // 解析property标签</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        // 解析qualifier标签</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(this.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line">        return bd;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    finally &#123;</span><br><span class="line">        this.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是解析的具体过程了，更具体的解析细节比较繁琐，不过逻辑简单，这里就不一一贴出来了，小伙伴们可以自己跟进去看看。</p>
<h5 id="3-import-标签解析方法-importBeanDefinitionResource"><a href="#3-import-标签解析方法-importBeanDefinitionResource" class="headerlink" title="3.import 标签解析方法 importBeanDefinitionResource"></a>3.import 标签解析方法 importBeanDefinitionResource</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void importBeanDefinitionResource(Element ele) &#123;</span><br><span class="line">    String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">    if (!StringUtils.hasText(location)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Resolve system properties: e.g. &quot;$&#123;user.dir&#125;&quot;</span><br><span class="line">    // 解析占位符</span><br><span class="line">    location = SystemPropertyUtils.resolvePlaceholders(location);</span><br><span class="line">    Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;Resource&gt;(4);</span><br><span class="line">    // 判断是绝对还是相对路径</span><br><span class="line">    boolean absoluteLocation = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">    &#125; catch (URISyntaxException ex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Absolute or relative?</span><br><span class="line">    if (absoluteLocation) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 确定是绝对路径后，直接交给 XmlBeanDefinitionReader 进行定位，加载，解析</span><br><span class="line">            int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">        &#125; catch (BeanDefinitionStoreException ex) &#123;&#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int importCount;</span><br><span class="line">            // 创建与当前资源同一父路径的相对资源</span><br><span class="line">            Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line">            if (relativeResource.exists()) &#123;</span><br><span class="line">                // 资源存在，直接加载</span><br><span class="line">                importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">                actualResources.add(relativeResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 资源不存在，表明路径是含有通配符的路径</span><br><span class="line">                String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">                importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                        StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //..........此处省略部分源码</span><br><span class="line">    &#125;</span><br><span class="line">    Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);</span><br><span class="line">    // 发送import事件</span><br><span class="line">    getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>import</code>标签解析比较简单，上面提到的资源 定位，加载方法: <code>loadBeanDefinitions</code>, 在<a href="https://me.oopcoder.cn/2019/10/18/spring-resource-load/">Spring容器加载过程源码解析之Resource定位加载</a>一文中有详细分析，想了解的小伙伴可以进去看看。</p>
<h5 id="4-alias-标签解析方法-processAliasRegistration"><a href="#4-alias-标签解析方法-processAliasRegistration" class="headerlink" title="4.alias 标签解析方法 processAliasRegistration"></a>4.alias 标签解析方法 processAliasRegistration</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void processAliasRegistration(Element ele) &#123;</span><br><span class="line">    String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">    boolean valid = true;</span><br><span class="line">    if (!StringUtils.hasText(name)) &#123;</span><br><span class="line">        valid = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">        valid = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 注册别名</span><br><span class="line">            getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">        &#125; catch (Exception ex) &#123;&#125;</span><br><span class="line">        // 发送alias注册事件</span><br><span class="line">        getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alias</code>标签跟<code>bean</code>标签下的<code>alias</code>属性都一样是<code>bean</code>的别名，那有什么作用呢？最简单的例子，比如，配置文件存在第三方<code>jar</code>包中，我们无法修改，但是又想通过特定的别名进行访问，这时候alias标签就派上用场了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// jar包中配置</span><br><span class="line">&lt;bean id=&quot;hello&quot;  name=&quot;hello-alias-1, hello-alias-2&quot;  class=“com.xx.xx&quot;/&gt;</span><br><span class="line">// 自己的配置</span><br><span class="line">&lt;alias name=&quot;hello&quot; alias=&quot;hello-alias-3&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;hello&quot; alias=&quot;hello-alias-4&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>按照上面这么配置，<code>hello</code> 就有4个别名了。</p>
<p>好了，今天的默认标签解析就分析到这里了，下篇文章我们再分析自定义标签是如何解析的。</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/spring/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>spring</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/10/21/spring-resource-parse/">
      Spring容器加载过程源码解析之Resource解析流程
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://me.oopcoder.cn" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>lanboys1225</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-10-21</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/spring/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>spring</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <blockquote>
<p>在上文 <a href="https://me.oopcoder.cn/2019/10/18/spring-resource-load/">Spring容器加载过程源码解析之Resource定位加载</a> 中，我们已经将资源路径解析为Resource了，今天我们来分析下整个解析流程。</p>
</blockquote>
<blockquote>
<p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p>
</blockquote>
<h5 id="1-XmlBeanDefinitionReader-分析"><a href="#1-XmlBeanDefinitionReader-分析" class="headerlink" title="1. XmlBeanDefinitionReader 分析"></a>1. XmlBeanDefinitionReader 分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这里才是真正将 资源路径 解析为Resource的地方</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            // 开始解析</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            //..........此处省略部分源码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int loadBeanDefinitions(Resource[] resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">    int counter = 0;</span><br><span class="line">    for (Resource resource : resources) &#123;</span><br><span class="line">        // 遍历所有资源 进行解析</span><br><span class="line">        counter += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        try &#123;</span><br><span class="line">            InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">            if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            // 从Resource获取输入流进行解析</span><br><span class="line">            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">        throws BeanDefinitionStoreException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int validationMode = getValidationModeForResource(resource);</span><br><span class="line">        // 通过 documentLoader 将资源转换为 Document 对象</span><br><span class="line">        Document doc = this.documentLoader.loadDocument(</span><br><span class="line">                inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());</span><br><span class="line">        return registerBeanDefinitions(doc, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// EntityResolver 由 BeansDtdResolver 和 PluggableSchemaResolver 组成</span><br><span class="line">// 用来在 classpath 下搜寻 schema 和 DTD 文件</span><br><span class="line">protected EntityResolver getEntityResolver() &#123;</span><br><span class="line">    if (this.entityResolver == null) &#123;</span><br><span class="line">        // Determine default EntityResolver to use.</span><br><span class="line">        ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">        if (resourceLoader != null) &#123;</span><br><span class="line">            this.entityResolver = new ResourceEntityResolver(resourceLoader);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.entityResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    // Read document based on new BeanDefinitionDocumentReader SPI.</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    // 委托 BeanDefinitionDocumentReader 解析document</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected XmlReaderContext createReaderContext(Resource resource) &#123;</span><br><span class="line">    if (this.namespaceHandlerResolver == null) &#123;</span><br><span class="line">        // 创建默认命名空间处理解析器</span><br><span class="line">        this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    return new XmlReaderContext(resource, this.problemReporter, this.eventListener,</span><br><span class="line">            this.sourceExtractor, this, this.namespaceHandlerResolver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() &#123;</span><br><span class="line">    // 用来解析 META-INF/spring.handlers 目录下对应的处理器，自定义标签的时候也会使用到，我们后面会详细分析</span><br><span class="line">    return new DefaultNamespaceHandlerResolver(getResourceLoader().getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中，我们看到XmlBeanDefinitionReader完成了如下工作：</p>
<ol>
<li>由内部的<code>ResourceLoader</code>去获取所有符合条件的<code>Resource</code> (上文已重点分析过 <a href="https://me.oopcoder.cn/2019/10/18/spring-resource-load/">Spring容器加载过程之源码解析之Resource定位加载</a>)；</li>
<li>从<code>Resource</code>中获取流，转化为方便解析的<code>Document</code>对象；</li>
<li>委托<code>BeanDefinitionDocumentReader</code>来解析 <code>Document</code>，所以实际的bean注册工作也是由它来完成。</li>
</ol>
<h5 id="2-DefaultBeanDefinitionDocumentReader-分析"><a href="#2-DefaultBeanDefinitionDocumentReader-分析" class="headerlink" title="2. DefaultBeanDefinitionDocumentReader 分析"></a>2. DefaultBeanDefinitionDocumentReader 分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">    this.readerContext = readerContext;</span><br><span class="line">    // 获取根元素，这里一般就是 beans 标签</span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    // 创建解析bean的代理类</span><br><span class="line">    BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);</span><br><span class="line">    // 与下方的 postProcessXml 一样，在这里都没有实现，可用来扩展自定义标签</span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    // 解析根元素</span><br><span class="line">    parseBeanDefinitions(root, delegate);</span><br><span class="line">    postProcessXml(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) &#123;</span><br><span class="line">    BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">    // 初始化默认的设置，即 beans 标签的属性</span><br><span class="line">    // Initialize the default lazy-init, autowire, dependency check settings, init-method, destroy-method and merge settings</span><br><span class="line">    delegate.initDefaults(root);</span><br><span class="line">    return delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // 判断是否为默认命名空间下的标签</span><br><span class="line">    if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123;</span><br><span class="line">        // 循环遍历 解析默认标签</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            if (node instanceof Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                String namespaceUri = delegate.getNamespaceURI(ele);</span><br><span class="line">                // 判断是否为默认命名空间下的标签</span><br><span class="line">                if (delegate.isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">                    // 默认标签解析方法</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 自定义标签解析方法</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 自定义标签解析方法</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        // 解析 import 标签</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        // 解析 alias 标签</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        // 解析 bean 标签</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到这里，<code>Resource</code> 解析的整个流程就清晰了许多，默认标签和自定义标签的具体解析我们将在后面的文章再来分析。</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/spring/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>spring</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/10/18/spring-resource-load/">
      Spring容器加载过程源码解析之Resource定位加载
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://me.oopcoder.cn" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>lanboys1225</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-10-18</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/spring/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>spring</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <blockquote>
<p>在上文 <a href="https://me.oopcoder.cn/2019/10/12/spring-startup-java/">如何手动启动Spring容器</a> 中，我们知道了可以通过传入资源文件来启动容器，如果将<code>applicationContext.xml</code>替换为绝对路径就启动不了，报错。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//启动容器</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)</span><br><span class="line"></span><br><span class="line">//更换为绝对路径，启动失败</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">                &quot;E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">//报 FileNotFoundException：Caused by: java.io.FileNotFoundException: class path resource [E:/IDEA_workspace/SpringLearningDemo/spring-java/src/main/resources/applicationContext.xml] cannot be opened because it does not exist</span><br><span class="line"></span><br><span class="line">//使用 FileSystemXmlApplicationContext 正常启动</span><br><span class="line">ApplicationContext context = new FileSystemXmlApplicationContext(</span><br><span class="line">                &quot;E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml&quot;);</span><br><span class="line">        </span><br><span class="line">// 启动成功</span><br><span class="line">ApplicationContext context = new FileSystemXmlApplicationContext(</span><br><span class="line">                &quot;classpath:applicationContext.xml&quot;);</span><br><span class="line">// 启动成功           </span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">                &quot;file:E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过字面意思，可以看出<code>ClassPathXmlApplicationContext</code>, 传入的是classpath目录下的资源文件, <code>FileSystemXmlApplicationContext</code>, 传入的是文件系统下资源文件(即文件绝对路径), 我们在资源文件前面加上 classpath 或 file，启动试试，发现也都成功了，看来资源的定位没有上面说的那么简单，还跟资源路径前缀有关。</p>
</blockquote>
<blockquote>
<p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p>
</blockquote>
<p>下面带着疑问来看看Spring资源到底是怎么定位和加载进来的。进入ClassPathXmlApplicationContext源码，按下面路径走, 找到getResources方法：</p>
<blockquote>
<p>refresh() -&gt; obtainFreshBeanFactory() -&gt; refreshBeanFactory() -&gt; loadBeanDefinitions(DefaultListableBeanFactory beanFactory)  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// AbstractXmlApplicationContext.java</span><br><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">    // 创建 XmlBeanDefinitionReader</span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    // 传入ResourceLoader</span><br><span class="line">    beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    if (configResources != null) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取容器启动时，传入的资源文件路径</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    if (configLocations != null) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AbstractBeanDefinitionReader.java</span><br><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">        // Resource pattern matching available.</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这里才是真正将 资源路径 解析为Resource的地方</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            //..........此处省略部分源码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，<code>AbstractXmlApplicationContext</code> 将<code>Bean</code>的装载任务委派给了<code>XmlBeanDefinitionReader</code>, 而<code>ResourceLoader</code>负责将<code>xml</code>解析为<code>Resource</code>。</p>
<p>先看看类结构图</p>
<p><img src="https://pic.superbed.cn/item/5da86a9b451253d1780df669.png" alt></p>
<p>从上面可以看到，Spring为了统一不同类型的资源访问，把所有资源都抽象成<code>Resource</code>接口, 屏蔽不同资源之间的差异，其实现了<code>InputStreamSource</code>, 这样所有<code>Resource</code>都可以通过<code>getInputStream()</code>获取<code>InputStream</code>。</p>
<p><img src="https://pic.superbed.cn/item/5da86eb4451253d1780e7ce3.png" alt></p>
<p>其中<code>资源定位路径 -&gt; Resource</code> 这个过程是由 <code>ResourceLoader</code> 这个类来完成的，我们暂且称之为: 资源定位器, 其默认实现是 <code>DefaultResourceLoader</code>。</p>
<p><code>ResourcePatternResolver</code> 继承自 <code>ResourceResolver</code> ，扩展了一个能通过<code>路径模式</code>匹配定位的方法： <code>Resource[] getResources(String locationPattern)</code>，其路径模式支持以  <code>classpath / classpath*</code> 或 URI协议名（例如 <code>http、file、jar:file</code>）为其前缀，还支持 <code>Ant风格</code> 的匹配模式。</p>
<p>看看 <code>ResourcePatternResolver</code> 的实现类 <code>PathMatchingResourcePatternResolver</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法创建的 DefaultResourceLoader</span><br><span class="line">private final ResourceLoader resourceLoader;</span><br><span class="line">// Ant风格 路径匹配器</span><br><span class="line">private PathMatcher pathMatcher = new AntPathMatcher();</span><br><span class="line"></span><br><span class="line">public Resource[] getResources(String locationPattern) throws IOException &#123;</span><br><span class="line">    if (locationPattern.startsWith(&quot;classpath*:&quot;)) &#123;</span><br><span class="line">        // &quot;classpath*:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式</span><br><span class="line">        if (getPathMatcher().isPattern(locationPattern.substring(&quot;classpath*:&quot;.length()))) &#123;</span><br><span class="line">            // eg: classpath*:a/b/applicationContext-*.xml</span><br><span class="line">            // 根据路径模式 查找所有匹配的资源</span><br><span class="line">            return findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // eg: classpath*:a/b/applicationContext-dao.xml 或 classpath*:a/b/</span><br><span class="line">            // 根据确定路径 在所有classpath中(包含所有jar包)查找资源</span><br><span class="line">            return findAllClassPathResources(locationPattern.substring(&quot;classpath*:&quot;.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 第一个 &quot;:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式</span><br><span class="line">        int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1;</span><br><span class="line">        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">            // 根据路径模式 查找所有匹配的资源</span><br><span class="line">            return findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 加载单个资源，后面再详细讲讲 getResource 这个方法</span><br><span class="line">            return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据路径模式 查找所有匹配的资源</span><br><span class="line">protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123;</span><br><span class="line">    // 获取到一个不含通配符的根目录，如 classpath*:a/b/*/applicationContext-*.xml 返回 classpath*:a/b/</span><br><span class="line">    String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">    // 返回 */applicationContext-*.xml</span><br><span class="line">    String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line">    // 递归调用getResources(), 获取的符合根目录的所有资源</span><br><span class="line">    Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">    Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(16);</span><br><span class="line">    // 遍历根目录资源，将匹配的资源添加到 result 中</span><br><span class="line">    for (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">        // jar:file:开头的为jar包资源</span><br><span class="line">        if (isJarResource(rootDirResource)) &#123;</span><br><span class="line">            result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));</span><br><span class="line">        &#125; else if (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirResource, subPattern, getPathMatcher()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他类型资源走这里</span><br><span class="line">            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toArray(new Resource[result.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    File rootDir = rootDirResource.getFile().getAbsoluteFile();</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    return doFindMatchingFileSystemResources(rootDir, subPattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Set&lt;Resource&gt; doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException &#123;</span><br><span class="line">    // retrieveMatchingFiles 流程比较长就不贴出来了，有兴趣的朋友可以debug进去看看</span><br><span class="line">    Set&lt;File&gt; matchingFiles = retrieveMatchingFiles(rootDir, subPattern);</span><br><span class="line">    Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(matchingFiles.size());</span><br><span class="line">    for (File file : matchingFiles) &#123;</span><br><span class="line">        // 符合条件的路径 此时就解析为Resource了</span><br><span class="line">        result.add(new FileSystemResource(file));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是<code>PathMatchingResourcePatternResolver</code>路径模式匹配的基本逻辑。加载单个资源的任务是委托给了构造方法里面创建的 <code>DefaultResourceLoader</code></p>
<p>DefaultResourceLoader 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Resource getResource(String location) &#123;</span><br><span class="line">    // 以 classpath: 开头的返回 ClassPathResource</span><br><span class="line">    if (location.startsWith(&quot;classpath:&quot;)) &#123;</span><br><span class="line">        return new ClassPathResource(location.substring(&quot;classpath:&quot;.length()), getClassLoader());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 能够解析为URL的返回 UrlResource</span><br><span class="line">            URL url = new URL(location);</span><br><span class="line">            return new UrlResource(url);</span><br><span class="line">        &#125; catch (MalformedURLException ex) &#123;</span><br><span class="line">            // 不能够解析为URL的 由getResourceByPath返回</span><br><span class="line">            return getResourceByPath(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Resource getResourceByPath(String path) &#123;</span><br><span class="line">    // 默认返回 ClassPathContextResource</span><br><span class="line">    return new ClassPathContextResource(path, getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的类结构图，我们看到 <code>FileSystemXmlApplicationContext</code> 和 <code>ClassPathXmlApplicationContext</code> 都是 <code>DefaultResourceLoader</code> 的子类，区别在于前者重写了 <code>getResourceByPath</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Resource getResourceByPath(String path) &#123;</span><br><span class="line">    if (path != null &amp;&amp; path.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">        path = path.substring(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return new FileSystemResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 不带前缀的 路径或者 自定义前缀 的路径能否定位成功，关键在于<code>getResourceByPath</code>方法了，回到文章开始 传入的路径:</p>
<p><code>applicationContext.xml</code> 和 <code>E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml</code></p>
<blockquote>
<p>走的是 DefaultResourceLoader 默认的 getResourceByPath方法，返回的classpath里面的资源，所以后者在ClassPathXmlApplicationContext里面是启动不了的，反之前者在FileSystemXmlApplicationContext也启动不了</p>
</blockquote>
<p><code>classpath:applicationContext.xml</code> 和 <code>file:E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml</code></p>
<blockquote>
<p>都带有前缀，所以跟getResourceByPath无关，也就是跟 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 无关，传入哪个Context都能启动成功</p>
</blockquote>
<p>总结起来, Spring的资源路径填写方式如下：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:</td>
<td>classpath:a/c.xml</td>
<td>从classpath中加载，存在多个资源则返回最先加载的那个资源，易导致资源加载不进来的问题</td>
</tr>
<tr>
<td>classpath*:</td>
<td>classpath*:a/c.xml</td>
<td>从classpath中加载，返回全部符合条件的资源，需要遍历所有classpath, 因此加载效率低</td>
</tr>
<tr>
<td>file: 或 jar:file: 等URI协议名</td>
<td>file:d:\b\f.xml</td>
<td>作为URL进行加载</td>
</tr>
<tr>
<td>没有前缀</td>
<td>a/c.xml 或 d:\b\f.xml</td>
<td>根据context的getResourceByPath方法判断</td>
</tr>
</tbody></table>
<p> Ant风格 的匹配模式</p>
<blockquote>
<p> “ ? ”：匹配一个字符, 如 a?.xml 匹配 ab.xml</p>
</blockquote>
<blockquote>
<p> “ * ”：匹配零个或多个字符串，如“a/ * /c.xml”将匹配“a/b/c.xml”，但不匹配匹配“a/c.xml”；而“a/c-*.xml”将匹配“a/c-dao.xml”</p>
</blockquote>
<blockquote>
<p>“ ** ”：匹配路径中的零个或多个目录，如“a/ ** /c.xml”将匹配“a /c.xml”，也匹配“a/b/b/c.xml”；而“a/b/c- ** .xml”将匹配“a/b/c-dao.xml”，即把“ ** ”当做两个“ * ”处理。</p>
</blockquote>
<p> 这就是Spring容器中资源的定位，然后通过 <code>Resource</code> 的 <code>getInputStream()</code> 加载进内存进行解析，至于如何解析，就请听下回分解啦。</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/spring/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>spring</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/10/12/spring-startup-java/">
      如何手动启动Spring容器
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://me.oopcoder.cn" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>lanboys1225</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-10-12</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/spring/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>spring</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>工作中，我想大家最熟悉的Spring容器启动方法，就是在web环境下，通过在web.xml中配置如下代码进行启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">   &lt;param-value&gt;classpath*:/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p>那么，离开了web环境，想单独的启动一个Spring容器该怎么做呢，其实也很简单，有两种方式，直接看代码：</p>
<h3 id="1-手动启动"><a href="#1-手动启动" class="headerlink" title="1. 手动启动"></a>1. 手动启动</h3><p>目录结构：</p>
<p><img src="https://pic.superbed.cn/item/5da1f344451253d178e6a6c6.png" alt></p>
<p>pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;3.0.0.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 日志依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0.13&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 单元测试依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- spring单元测试依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>applicationContext.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">						http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">						http://www.springframework.org/schema/context</span><br><span class="line">						http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">						</span><br><span class="line">    &lt;bean id=&quot;helloWorld-id&quot; name=&quot;helloWorld&quot; class=&quot;com.bing.lan.spring.HelloWorld&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>日志配置： logback.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration debug=&quot;true&quot;&gt;</span><br><span class="line">    &lt;contextName&gt;spring&lt;/contextName&gt;</span><br><span class="line">    &lt;property name=&quot;NORMAL_PATTERN&quot;</span><br><span class="line">              value=&quot; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level - %logger&#123;100&#125; - %msg%n&quot;/&gt;</span><br><span class="line">              </span><br><span class="line">    &lt;Appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;Layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;Pattern&gt;$&#123;NORMAL_PATTERN&#125;&lt;/Pattern&gt;</span><br><span class="line">        &lt;/Layout&gt;</span><br><span class="line">    &lt;/Appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ROOT level=&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;Appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/ROOT&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure>

<p>HelloWorld.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">    private String name = &quot;OOPcoder&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HelloWorld&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringStartup.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.bing.lan.spring;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class SpringStartup &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 手动启动spring容器</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        </span><br><span class="line">        HelloWorld helloWorld = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        System.out.println(&quot;main(): &quot; + helloWorld);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动main函数，容器就启动了。</p>
<h3 id="2-通过-junit-来启动"><a href="#2-通过-junit-来启动" class="headerlink" title="2. 通过 junit 来启动"></a>2. 通过 junit 来启动</h3><p>在上面这些类的基础上再添加一个测试类</p>
<p>SpringTest.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.bing.lan.spring;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span><br><span class="line">public class SpringTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        HelloWorld helloWorld = (HelloWorld) applicationContext.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        System.out.println(&quot;main(): &quot; + helloWorld);</span><br><span class="line"></span><br><span class="line">        helloWorld = (HelloWorld) beanFactory.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        System.out.println(&quot;main(): &quot; + helloWorld);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行test()，容器启动成功。</p>
<p>学会了怎么启动，有啥好处呢，好处很多，比如</p>
<blockquote>
<ol>
<li><p>可以脱离web环境测试我们的 service / mapper 层，极大的提高开发效率；</p>
</li>
<li><p>还可以debug进Spring源码里学习各种原理，这对我们小白来说，是非常友好的，因为这只是一个单纯的Spring, 没有其他框架的干扰。</p>
</li>
</ol>
</blockquote>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/spring/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>spring</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  

</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='https://me.oopcoder.cn/assets/images/oopcoder.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:oopcoder@163.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/lanboys1225"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=1290850143"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/blog/archives/" href="/blog/archives/"
          
            rel="nofollow"
          
          
          id="blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/lanboys1225" href="https://github.com/lanboys1225"
          
          
          id="https:github.comlanboys1225">
          
            <i class="fas fa-code-branch fa-fw" aria-hidden="true"></i>
          
          开源项目
        </a></li>
      
        <li><a class="flat-box" title="/friends/" href="/friends/"
          
            rel="nofollow"
          
          
          id="friends">
          
            <i class="fas fa-link fa-fw" aria-hidden="true"></i>
          
          我的友链
        </a></li>
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/material-x/" href="https://xaoxuu.com/wiki/material-x/"
          
            rel="nofollow"
          
          
          id="https:xaoxuu.comwikimaterial-x">
          
            <i class="fas fa-book fa-fw" aria-hidden="true"></i>
          
          主题文档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/blog/categories/hexo/" href="/blog/categories/hexo/"><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/html/" href="/blog/categories/html/"><div class='name'>html</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/linux/" href="/blog/categories/linux/"><div class='name'>linux</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/maven/" href="/blog/categories/maven/"><div class='name'>maven</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/spring/" href="/blog/categories/spring/"><div class='name'>spring</div><div class='badge'>(6)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/blog/tags/banner/" style="font-size: 14px; color: #999">banner</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/html/" style="font-size: 14px; color: #999">html</a> <a href="/blog/tags/iframe/" style="font-size: 14px; color: #999">iframe</a> <a href="/blog/tags/linux/" style="font-size: 14px; color: #999">linux</a> <a href="/blog/tags/maven/" style="font-size: 14px; color: #999">maven</a> <a href="/blog/tags/pom/" style="font-size: 14px; color: #999">pom</a> <a href="/blog/tags/spring/" style="font-size: 24px; color: #555">spring</a> <a href="/blog/tags/swiper/" style="font-size: 14px; color: #999">swiper</a> <a href="/blog/tags/xshell/" style="font-size: 14px; color: #999">xshell</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="https://music.163.com/#/user/home?id=1290850143"
    title="https://music.163.com/#/user/home?id=1290850143">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="1983459158"
    data-volume="0.7">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:oopcoder@163.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/lanboys1225"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=1290850143"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
