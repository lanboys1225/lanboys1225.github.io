{"meta":{"title":"OOPcoder","subtitle":null,"description":null,"author":"lanboys1225","url":"http://me.oopcoder.cn","root":"/"},"pages":[{"title":"关于","date":"2019-08-10T09:19:05.070Z","updated":"2019-08-10T09:19:05.070Z","comments":true,"path":"about/index.html","permalink":"http://me.oopcoder.cn/about/index.html","excerpt":"","text":"这是我的个人博客项目，里面会记录生活和技术的点点滴滴。 访问地址：https://me.oopcoder.cn 我的微信公众号 OOPcoder 欢迎留言～"},{"title":"我的朋友们","date":"2019-08-05T07:45:07.344Z","updated":"2019-08-05T07:45:07.344Z","comments":true,"path":"friends/index.html","permalink":"http://me.oopcoder.cn/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： OOPcoder头像： https://me.oopcoder.cn/assets/images/oopcoder.jpg网址： https://me.oopcoder.cn标签： Java"},{"title":"所有分类","date":"2019-08-03T08:47:32.659Z","updated":"2019-08-01T07:42:58.161Z","comments":true,"path":"blog/categories/index.html","permalink":"http://me.oopcoder.cn/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-08-03T09:23:15.295Z","updated":"2019-08-03T09:23:15.295Z","comments":true,"path":"blog/tags/index.html","permalink":"http://me.oopcoder.cn/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring容器源码解析之Bean的实例化(一)","slug":"spring-bean-instantiate-1","date":"2019-12-12T08:03:12.000Z","updated":"2019-12-12T07:49:26.641Z","comments":true,"path":"2019/12/12/spring-bean-instantiate-1/","link":"","permalink":"http://me.oopcoder.cn/2019/12/12/spring-bean-instantiate-1/","excerpt":"","text":"提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了 Spring容器加载过程源码解析之Resource定位加载 Spring容器加载过程源码解析之Resource解析流程 Spring容器加载过程源码解析之默认标签解析 Spring容器加载过程源码解析之自定义标签解析 经过上面【Spring加载过程源码解析系列】的学习，我们完成了 Bean配置的解析和注册过程，容器中存在的是 Bean 对应的 BeanDefinition,Bean并没有完成实例化，接下来我们看看到底是怎么实例化的。 开门见山，Bean 的实例化是在使用前完成的，即在方法 getBean 中 实例化。 1. getBean123456789101112131415public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125;public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123; return doGetBean(name, requiredType, null, false);&#125;public Object getBean(String name, Object... args) throws BeansException &#123; return doGetBean(name, null, args, false);&#125;public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123; return doGetBean(name, requiredType, args, false);&#125; 四个重载方法都指向了 doGetBean 方法 2. doGetBean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104private &lt;T&gt; T doGetBean(final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 将传入的name转换为实际的beanName, a -&gt; a ; &amp;a -&gt; a; // 如果该bean类型class是FactoryBean, 无论是getBean(a),还是getBean(&amp;a), // 都是先实例化FactoryBean, 然后再返回实际需要的bean final String beanName = transformedBeanName(name); Object bean; // 先从缓存中获取单例 Object sharedInstance = getSingleton(beanName); // 缓存中存在单例，并且 args 为空(因为只有prototype才能带参数 args)，才进入 getObjectForBeanInstance if (sharedInstance != null &amp;&amp; args == null) &#123; // 获取实际需要的bean, sharedInstance 可能为 FactoryBean bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 检查是否为 当前线程正在创建的prototype 实例 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // 检查是否存在当前beanFactory中，不存在则去父工厂(存在的话)中找 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; String nameToLookup = originalBeanName(name); if (args != null) &#123; return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; // 检查是否只是为了类型检查而创建bean, 不是的话将beanName添加到已创建bean容器中 // removeSingletonIfCreatedForTypeCheckOnly() 方法可移除只用来检查类型创建的bean if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; // 获取合并后的根 BeanDefinition，BeanDefintiton 根类一样具有继承关系 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 将依赖的bean提前创建 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dependsOnBean : dependsOn) &#123; getBean(dependsOnBean); // 注册依赖 bean registerDependentBean(dependsOnBean, beanName); &#125; &#125; // 创建单例实例 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory() &#123; public Object getObject() throws BeansException &#123; try &#123; // 创建bean return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 创建原型实例 else if (mbd.isPrototype()) &#123; // It&apos;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; // 创建自定义Scope实例, CustomScopeConfigurer / SimpleThreadScope else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory() &#123; public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123;&#125; &#125; &#125; // 检查获取到的bean与参数 requiredType 是否匹配 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; return (T) bean;&#125; doGetBean 方法里面调用了几个比较重要的方法： getSingleton(String beanName); getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd); getMergedLocalBeanDefinition(String beanName); getSingleton(String beanName, ObjectFactory singletonFactory); createBean(String beanName, RootBeanDefinition mbd, Object[] args)。 3. getSingleton我们先看看getSingleton(String beanName, ObjectFactory singletonFactory) 123456789101112131415161718192021public Object getSingleton(String beanName, ObjectFactory singletonFactory) &#123; synchronized (this.singletonObjects) &#123; // 先从缓存中获取 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; // 标记当前 beanName 正在创建 beforeSingletonCreation(beanName); try &#123; // 调用 createBean() singletonObject = singletonFactory.getObject(); &#125; catch (BeanCreationException ex) &#123; throw ex; &#125; finally &#123; afterSingletonCreation(beanName); &#125; // 添加到缓存中 addSingleton(beanName, singletonObject); &#125; return (singletonObject != NULL_OBJECT ? singletonObject : null); &#125;&#125; 4. createBean1234567891011121314151617181920212223242526protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // Make sure bean class is actually resolved at this point. // 将bean标签中class属性解析为Class类 resolveBeanClass(mbd, beanName); // 检查 MethodOverrides, 主要是检查 MethodOverride 里面的 methodName 是否存在，或者是否重载 try &#123; mbd.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 给BeanPostProcessors机会返回一个代理bean, 替代掉目标bean Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(); &#125; // 创建 bean Object beanInstance = doCreateBean(beanName, mbd, args); return beanInstance;&#125; 5. doCreateBean看看真正创建Bean的方法 doCreateBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; // 如果是单例，看是否存在FactoryBean缓存，这个缓存主要是在调用 isTypeMatch() 或 getType() 检查类型匹配或者获取类型后缓存起来的 if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 创建Bean实例，并返回Bean的包装实例 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; // post-processors 可以在此修改definition applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); // 这里的目的就是解决循环依赖的问题 if (earlySingletonExposure) &#123; addSingletonFactory(beanName, new ObjectFactory() &#123; public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 将xml文件配置的各种属性值填充到Bean中 populateBean(beanName, mbd, instanceWrapper); // 初始化bean, 顺序：postProcessBeforeInitialization() -&gt; afterPropertiesSet() -&gt; // 自定义的 init-method -&gt; postProcessAfterInitialization() exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable ex) &#123;&#125; ...... return exposedObject;&#125; Bean实例化的大致流程基本上就是这样了，上面提到的一些重要方法这里还没具体看，我们下次再来分析一波。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"Spring容器加载过程源码解析之自定义标签解析","slug":"spring-resource-parse-custom-element","date":"2019-11-01T06:03:12.000Z","updated":"2019-11-01T06:16:05.707Z","comments":true,"path":"2019/11/01/spring-resource-parse-custom-element/","link":"","permalink":"http://me.oopcoder.cn/2019/11/01/spring-resource-parse-custom-element/","excerpt":"","text":"在上文 Spring容器加载过程源码解析之默认标签解析 中，我们学习了默认标签的解析，今天我们来看看自定义的标签和属性是如何解析的。 提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了 1. 常用的自定义标签和属性自定义标签：&lt;context:annotation-config/&gt;, &lt;context:component-scan base-package=&quot;com.xx.xx&quot;/&gt;, &lt;mvc:annotation-driven&gt;, &lt;aop:aspectj-autoproxy/&gt;等等都是自定义的标签； 自定义属性见得比较少，不过也有，如带 “p” 前缀的属性，是在spring-beansjar包中。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 启用注解 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 设置扫描的包 --&gt; &lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.xxx.Hello&quot;/&gt; &lt;!-- p:hello-ref 定义 HelloWorld 属性 hello，有后缀 -ref 表示bean的id --&gt; &lt;!-- p:world 定义 HelloWorld 属性 world 的值 --&gt; &lt;!-- p:world 会与下方的 property world 冲突 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.xxx.HelloWorld&quot; p:hello-ref=&quot;hello&quot; p:world=&quot;world-value-p&quot;&gt; &lt;property name=&quot;world&quot; value=&quot;world-value&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 2. parseCustomElement分析我们先从自定义标签解析方法的起始位置 DefaultBeanDefinitionDocumentReader#parseBeanDefinitions 看起 12345678910111213141516171819202122232425protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // 判断是否为默认命名空间下的标签 if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123; // 循环遍历 解析默认标签 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; String namespaceUri = delegate.getNamespaceURI(ele); // 判断是否为默认命名空间下的标签 if (delegate.isDefaultNamespace(namespaceUri)) &#123; // 默认标签解析方法 parseDefaultElement(ele, delegate); &#125; else &#123; // 自定义标签解析方法 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; // 自定义标签解析方法 delegate.parseCustomElement(root); &#125;&#125; 委托给了BeanDefinitionParserDelegate#parseCustomElement进行解析 123456789101112131415public BeanDefinition parseCustomElement(Element ele) &#123; return parseCustomElement(ele, null);&#125;public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(ele); // 根据命名空间获取对应的处理器 (命名空间处理解析器,下面会分析) NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele); return null; &#125; // 处理器进行解析 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 3. NamespaceHandler分析 结合上面类图，查看源码发现，命名空间处理器的主要逻辑是放在其子类NamespaceHandlerSupport中，而NamespaceHandlerSupport的子类主要是实现init方法，在里面注册该命名空间下标签对应的解析器，如ContextNamespaceHandler的init方法，一个标签对应一个解析器。 1234567891011public void init() &#123; // 注册解析器 BeanDefinitionParser registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());&#125; NamespaceHandler调用解析器进行解析的方法是 parse 123456789101112131415public BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 查找对应的解析器进行解析 return findParserForElement(element, parserContext).parse(element, parserContext);&#125;private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123; String localName = parserContext.getDelegate().getLocalName(element); // 根据标签名获取解析器 BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) &#123; parserContext.getReaderContext().fatal( &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element); &#125; return parser;&#125; 4. BeanDefinitionParser分析我们拿常用的context:component-scan标签解析器看看 12345678910111213public BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 获取 base-package 值 String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. // 扫描并注册 ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null;&#125; 不同标签的具体解析逻辑就在parse方法中了。 5. NamespaceHandler的注册我们在前面提过的命名空间处理解析器，用来解析命名空间对应的处理器 1NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 它的默认实现是DefaultNamespaceHandlerResolver 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public NamespaceHandler resolve(String namespaceUri) &#123; // 获取所有处理器 Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; else &#123; String className = (String) handlerOrClassName; try &#123; Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; throw new FatalBeanException(&quot;.....&quot;); &#125; // 实例化处理器 NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); // 初始化处理器，里面就是注册解析器 namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125; //..........此处省略部分源码 &#125;&#125;private Map&lt;String, Object&gt; getHandlerMappings() &#123; if (this.handlerMappings == null) &#123; synchronized (this) &#123; if (this.handlerMappings == null) &#123; try &#123; // 加载 META-INF/spring.handlers 属性文件 // this.handlerMappingsLocation = &quot;META-INF/spring.handlers&quot; Properties mappings = PropertiesLoaderUtils .loadAllProperties(this.handlerMappingsLocation, this.classLoader); Map&lt;String, Object&gt; handlerMappings = new ConcurrentHashMap&lt;String, Object&gt;(); CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings); this.handlerMappings = handlerMappings; &#125; //..........此处省略部分源码 &#125; &#125; &#125; return this.handlerMappings;&#125; 代码中出现了&quot;META-INF/spring.handlers&quot;这么一个文件，打开spring-beans,spring-contextjar包下该文件，有如下内容： 1234567891011spring-beans下http\\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandlerhttp\\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandlerspring-context下http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandlerhttp\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandlerhttp\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandlerhttp\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler 我们看到命名空间 http\\://www.springframework.org/schema/context的处理器org.springframework.context.config.ContextNamespaceHandler的对应关系就是在这里确定的。 6. 自定义属性解析我们来回顾下 BeanDefinitionParserDelegate#parseBeanDefinitionElement方法 123456789101112131415protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // bean标签比较复杂，委托给了BeanDefinitionParserDelegate进行解析，返回封装了含 BeanDefinition，beanName，aliases 的BeanDefinitionHolder BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; // 解析自定义属性或标签 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. // 注册到 BeanDefinitionRegistry，也就是DefaultListableBeanFactory中的 beanDefinitionMap 中 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125;catch (BeanDefinitionStoreException ex) &#123;&#125; // Send registration event. 发送bean注册事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder)就是自定义属性的入口了 123456789101112131415161718192021222324252627282930313233343536373839public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder) &#123; return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);&#125;public BeanDefinitionHolder decorateBeanDefinitionIfRequired( Element ele, BeanDefinitionHolder definitionHolder, BeanDefinition containingBd) &#123; BeanDefinitionHolder finalDefinition = definitionHolder; // Decorate based on custom attributes first. NamedNodeMap attributes = ele.getAttributes(); for (int i = 0; i &lt; attributes.getLength(); i++) &#123; Node node = attributes.item(i); // 遍历属性 finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); &#125; // Decorate based on custom nested elements. NodeList children = ele.getChildNodes(); for (int i = 0; i &lt; children.getLength(); i++) &#123; Node node = children.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; // 遍历子标签 finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); &#125; &#125; return finalDefinition;&#125;private BeanDefinitionHolder decorateIfRequired( Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(node); if (!isDefaultNamespace(namespaceUri)) &#123; // 这里跟前面的逻辑类似，就不重复讲了 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler != null) &#123; return handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd)); &#125; //..........此处省略部分源码 &#125; return originalDef;&#125; 看看装饰方法NamespaceHandlerSupport#decorate 12345678910111213141516171819public BeanDefinitionHolder decorate( Node node, BeanDefinitionHolder definition, ParserContext parserContext) &#123; return findDecoratorForNode(node, parserContext).decorate(node, definition, parserContext);&#125;private BeanDefinitionDecorator findDecoratorForNode(Node node, ParserContext parserContext) &#123; BeanDefinitionDecorator decorator = null; String localName = parserContext.getDelegate().getLocalName(node); if (node instanceof Element) &#123; // 获取元素装饰器 decorator = this.decorators.get(localName); &#125; else if (node instanceof Attr) &#123; // 获取属性装饰器 decorator = this.attributeDecorators.get(localName); &#125; //..........此处省略部分源码 return decorator;&#125; 再看看另外一个处理器 SimplePropertyNamespaceHandler的实现，这个处理器对应的是带 “p” 前缀的属性 12345678910111213141516171819202122public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) &#123; if (node instanceof Attr) &#123; Attr attr = (Attr) node; String propertyName = parserContext.getDelegate().getLocalName(attr); String propertyValue = attr.getValue(); MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues(); // 判断是否已经存在，默认标签优先解析 if (pvs.contains(propertyName)) &#123; parserContext.getReaderContext().error(&quot;Property &apos;&quot; + propertyName + &quot;&apos; is already defined using &quot; + &quot;both &lt;property&gt; and inline syntax. Only one approach may be used per property.&quot;, attr); &#125; // 以 &quot;-ref&quot; 结尾，表示的是值为beanName，非具体值 if (propertyName.endsWith(&quot;-ref&quot;)) &#123; propertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length()); pvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue)); &#125; else &#123; // 将值添加到definition中 pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue); &#125; &#125; return definition;&#125; 相信大家看到这里应该明白自定义的标签或属性是怎么解析的了，大家可以尝试去定义一下自己的属性标签，这里就不带大家去实践了。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"Spring容器加载过程源码解析之默认标签解析","slug":"spring-resource-parse-default-element","date":"2019-10-27T10:33:12.000Z","updated":"2019-10-28T01:28:32.735Z","comments":true,"path":"2019/10/27/spring-resource-parse-default-element/","link":"","permalink":"http://me.oopcoder.cn/2019/10/27/spring-resource-parse-default-element/","excerpt":"","text":"在上文 Spring容器加载过程源码解析之Resource解析流程 中，我们已经了解了整个解析流程，今天我们来具体分析下默认标签的解析。 提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了 1.什么是默认标签和自定义标签12345678910111213141516171819202122232425262728293031323334353637383940414243protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // 判断是否为默认命名空间下的标签 if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123; // 循环遍历 解析默认标签 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; String namespaceUri = delegate.getNamespaceURI(ele); // 判断是否为默认命名空间下的标签 if (delegate.isDefaultNamespace(namespaceUri)) &#123; // 默认标签解析方法 parseDefaultElement(ele, delegate); &#125; else &#123; // 自定义标签解析方法 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; // 自定义标签解析方法 delegate.parseCustomElement(root); &#125;&#125;// 判断是否为默认命名空间下的标签public boolean isDefaultNamespace(String namespaceUri) &#123; return (!StringUtils.hasLength(namespaceUri) || &quot;http://www.springframework.org/schema/beans&quot;.equals(namespaceUri));&#125;private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; // 解析 import 标签 importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; // 解析 alias 标签 processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; // 解析 bean 标签 processBeanDefinition(ele, delegate); &#125;&#125; 从 isDefaultNamespace() 方法可以看出，在命名空间 http://www.springframework.org/schema/beans 下面定义的标签就是我们所说的默认标签，比如顶级标签 beans, 以及下面的 bean,import,alias等等其他标签。 而不在默认命名空间下的标签就是自定义标签了，比如我们最常见的带 context 前缀的标签：&lt;context:annotation-config/&gt;,&lt;context:component-scan base-package=&quot;com.xx.xx&quot;/&gt;等。 2.bean 标签解析方法 processBeanDefinition委托给了BeanDefinitionParserDelegate#parseBeanDefinitionElement进行解析，解析完成后再进行注册。 123456789101112131415protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // bean标签比较复杂，委托给了BeanDefinitionParserDelegate进行解析，返回封装了含 BeanDefinition，beanName，aliases 的BeanDefinitionHolder BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; // 解析自定义属性或标签 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. // 注册到 BeanDefinitionRegistry，也就是DefaultListableBeanFactory中的 beanDefinitionMap 中 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125;catch (BeanDefinitionStoreException ex) &#123;&#125; // Send registration event. 发送bean注册事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 接下看看代理类 BeanDefinitionParserDelegate 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123; // beans 标签下的 bean, containingBean 为空 return parseBeanDefinitionElement(ele, null);&#125;public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; // 获取属性 id 值，用作 beanName String id = ele.getAttribute(&quot;id&quot;); // 获取属性 name 值，用作别名, 多个别名可用‘，’或‘；’分割开来 String nameAttr = ele.getAttribute(&quot;name&quot;); // 分割多个别名 List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; // 属性id值作为 bean 的名称 String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; // 如果未定义id, 则将 第一个别名作为 beanName beanName = aliases.remove(0); &#125; // beans 标签下的bean, 需要检查beanName和aliases的在当前xml配置文件中的唯一性 // bean 标签中嵌套的 bean 不需要检查 if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; // 解析标签的具体操作 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; // 下面主要是没有定义 beanName 时，名字自动生成的逻辑 if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; &#125; //..........此处省略部分源码 &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 holder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; 上面这部分主要是处理名字和别名的逻辑，下面看下解析的具体操作 12345678910111213141516171819202122232425262728293031323334353637383940414243public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; // 解析 class 属性 if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; // 解析 parent 属性 if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; // 创建GenericBeanDefinition实例 AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 解析其他属性 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析meta标签 parseMetaElements(ele, bd); // 解析lookup-method标签 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析replaced-method标签 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析constructor-arg标签 parseConstructorArgElements(ele, bd); // 解析property标签 parsePropertyElements(ele, bd); // 解析qualifier标签 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; //..........此处省略部分源码 finally &#123; this.parseState.pop(); &#125; return null;&#125; 上面就是解析的具体过程了，更具体的解析细节比较繁琐，不过逻辑简单，这里就不一一贴出来了，小伙伴们可以自己跟进去看看。 3.import 标签解析方法 importBeanDefinitionResource12345678910111213141516171819202122232425262728293031323334353637383940414243protected void importBeanDefinitionResource(Element ele) &#123; String location = ele.getAttribute(RESOURCE_ATTRIBUTE); if (!StringUtils.hasText(location)) &#123; return; &#125; // Resolve system properties: e.g. &quot;$&#123;user.dir&#125;&quot; // 解析占位符 location = SystemPropertyUtils.resolvePlaceholders(location); Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;Resource&gt;(4); // 判断是绝对还是相对路径 boolean absoluteLocation = false; try &#123; absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); &#125; catch (URISyntaxException ex) &#123;&#125; // Absolute or relative? if (absoluteLocation) &#123; try &#123; // 确定是绝对路径后，直接交给 XmlBeanDefinitionReader 进行定位，加载，解析 int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources); &#125; catch (BeanDefinitionStoreException ex) &#123;&#125; &#125; else &#123; try &#123; int importCount; // 创建与当前资源同一父路径的相对资源 Resource relativeResource = getReaderContext().getResource().createRelative(location); if (relativeResource.exists()) &#123; // 资源存在，直接加载 importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource); actualResources.add(relativeResource); &#125; else &#123; // 资源不存在，表明路径是含有通配符的路径 String baseLocation = getReaderContext().getResource().getURL().toString(); importCount = getReaderContext().getReader().loadBeanDefinitions( StringUtils.applyRelativePath(baseLocation, location), actualResources); &#125; &#125; //..........此处省略部分源码 &#125; Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]); // 发送import事件 getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));&#125; import标签解析比较简单，上面提到的资源 定位，加载方法: loadBeanDefinitions, 在Spring容器加载过程源码解析之Resource定位加载一文中有详细分析，想了解的小伙伴可以进去看看。 4.alias 标签解析方法 processAliasRegistration12345678910111213141516171819protected void processAliasRegistration(Element ele) &#123; String name = ele.getAttribute(NAME_ATTRIBUTE); String alias = ele.getAttribute(ALIAS_ATTRIBUTE); boolean valid = true; if (!StringUtils.hasText(name)) &#123; valid = false; &#125; if (!StringUtils.hasText(alias)) &#123; valid = false; &#125; if (valid) &#123; try &#123; // 注册别名 getReaderContext().getRegistry().registerAlias(name, alias); &#125; catch (Exception ex) &#123;&#125; // 发送alias注册事件 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); &#125;&#125; alias标签跟bean标签下的alias属性都一样是bean的别名，那有什么作用呢？最简单的例子，比如，配置文件存在第三方jar包中，我们无法修改，但是又想通过特定的别名进行访问，这时候alias标签就派上用场了。 12345// jar包中配置&lt;bean id=&quot;hello&quot; name=&quot;hello-alias-1, hello-alias-2&quot; class=“com.xx.xx&quot;/&gt;// 自己的配置&lt;alias name=&quot;hello&quot; alias=&quot;hello-alias-3&quot;/&gt;&lt;alias name=&quot;hello&quot; alias=&quot;hello-alias-4&quot;/&gt; 按照上面这么配置，hello 就有4个别名了。 好了，今天的默认标签解析就分析到这里了，下篇文章我们再分析自定义标签是如何解析的。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"Spring容器加载过程源码解析之Resource解析流程","slug":"spring-resource-parse","date":"2019-10-21T14:55:42.000Z","updated":"2019-10-28T01:28:32.743Z","comments":true,"path":"2019/10/21/spring-resource-parse/","link":"","permalink":"http://me.oopcoder.cn/2019/10/21/spring-resource-parse/","excerpt":"","text":"在上文 Spring容器加载过程源码解析之Resource定位加载 中，我们已经将资源路径解析为Resource了，今天我们来分析下整个解析流程。 提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了 1. XmlBeanDefinitionReader 分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; ResourceLoader resourceLoader = getResourceLoader(); //..........此处省略部分源码 if (resourceLoader instanceof ResourcePatternResolver) &#123; try &#123; // 这里才是真正将 资源路径 解析为Resource的地方 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); // 开始解析 int loadCount = loadBeanDefinitions(resources); //..........此处省略部分源码 &#125; &#125; //..........此处省略部分源码&#125;public int loadBeanDefinitions(Resource[] resources) throws BeanDefinitionStoreException &#123; Assert.notNull(resources, &quot;Resource array must not be null&quot;); int counter = 0; for (Resource resource : resources) &#123; // 遍历所有资源 进行解析 counter += loadBeanDefinitions(resource); &#125; return counter;&#125;public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125;public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; //..........此处省略部分源码 try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 从Resource获取输入流进行解析 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; //..........此处省略部分源码&#125;protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; int validationMode = getValidationModeForResource(resource); // 通过 documentLoader 将资源转换为 Document 对象 Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware()); return registerBeanDefinitions(doc, resource); &#125; //..........此处省略部分源码&#125;// EntityResolver 由 BeansDtdResolver 和 PluggableSchemaResolver 组成// 用来在 classpath 下搜寻 schema 和 DTD 文件protected EntityResolver getEntityResolver() &#123; if (this.entityResolver == null) &#123; // Determine default EntityResolver to use. ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader != null) &#123; this.entityResolver = new ResourceEntityResolver(resourceLoader); &#125; else &#123; this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader()); &#125; &#125; return this.entityResolver;&#125;public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; // Read document based on new BeanDefinitionDocumentReader SPI. BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // 委托 BeanDefinitionDocumentReader 解析document documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125;protected XmlReaderContext createReaderContext(Resource resource) &#123; if (this.namespaceHandlerResolver == null) &#123; // 创建默认命名空间处理解析器 this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver(); &#125; return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, this.namespaceHandlerResolver);&#125;protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() &#123; // 用来解析 META-INF/spring.handlers 目录下对应的处理器，自定义标签的时候也会使用到，我们后面会详细分析 return new DefaultNamespaceHandlerResolver(getResourceLoader().getClassLoader());&#125; 从上述代码中，我们看到XmlBeanDefinitionReader完成了如下工作： 由内部的ResourceLoader去获取所有符合条件的Resource (上文已重点分析过 Spring容器加载过程之源码解析之Resource定位加载)； 从Resource中获取流，转化为方便解析的Document对象； 委托BeanDefinitionDocumentReader来解析 Document，所以实际的bean注册工作也是由它来完成。 2. DefaultBeanDefinitionDocumentReader 分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; // 获取根元素，这里一般就是 beans 标签 Element root = doc.getDocumentElement(); // 创建解析bean的代理类 BeanDefinitionParserDelegate delegate = createHelper(readerContext, root); // 与下方的 postProcessXml 一样，在这里都没有实现，可用来扩展自定义标签 preProcessXml(root); // 解析根元素 parseBeanDefinitions(root, delegate); postProcessXml(root);&#125;protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) &#123; BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext); // 初始化默认的设置，即 beans 标签的属性 // Initialize the default lazy-init, autowire, dependency check settings, init-method, destroy-method and merge settings delegate.initDefaults(root); return delegate;&#125;protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // 判断是否为默认命名空间下的标签 if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123; // 循环遍历 解析默认标签 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; String namespaceUri = delegate.getNamespaceURI(ele); // 判断是否为默认命名空间下的标签 if (delegate.isDefaultNamespace(namespaceUri)) &#123; // 默认标签解析方法 parseDefaultElement(ele, delegate); &#125; else &#123; // 自定义标签解析方法 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; // 自定义标签解析方法 delegate.parseCustomElement(root); &#125;&#125;private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; // 解析 import 标签 importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; // 解析 alias 标签 processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; // 解析 bean 标签 processBeanDefinition(ele, delegate); &#125;&#125; 来到这里，Resource 解析的整个流程就清晰了许多，默认标签和自定义标签的具体解析我们将在后面的文章再来分析。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"Spring容器加载过程源码解析之Resource定位加载","slug":"spring-resource-load","date":"2019-10-18T07:03:02.000Z","updated":"2019-10-22T01:41:44.316Z","comments":true,"path":"2019/10/18/spring-resource-load/","link":"","permalink":"http://me.oopcoder.cn/2019/10/18/spring-resource-load/","excerpt":"","text":"在上文 如何手动启动Spring容器 中，我们知道了可以通过传入资源文件来启动容器，如果将applicationContext.xml替换为绝对路径就启动不了，报错。 12345678910111213141516171819//启动容器ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)//更换为绝对路径，启动失败ApplicationContext context = new ClassPathXmlApplicationContext( &quot;E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;);//报 FileNotFoundException：Caused by: java.io.FileNotFoundException: class path resource [E:/IDEA_workspace/SpringLearningDemo/spring-java/src/main/resources/applicationContext.xml] cannot be opened because it does not exist//使用 FileSystemXmlApplicationContext 正常启动ApplicationContext context = new FileSystemXmlApplicationContext( &quot;E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;); // 启动成功ApplicationContext context = new FileSystemXmlApplicationContext( &quot;classpath:applicationContext.xml&quot;);// 启动成功 ApplicationContext context = new ClassPathXmlApplicationContext( &quot;file:E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;); 通过字面意思，可以看出ClassPathXmlApplicationContext, 传入的是classpath目录下的资源文件, FileSystemXmlApplicationContext, 传入的是文件系统下资源文件(即文件绝对路径), 我们在资源文件前面加上 classpath 或 file，启动试试，发现也都成功了，看来资源的定位没有上面说的那么简单，还跟资源路径前缀有关。 提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了 下面带着疑问来看看Spring资源到底是怎么定位和加载进来的。进入ClassPathXmlApplicationContext源码，按下面路径走, 找到getResources方法： refresh() -&gt; obtainFreshBeanFactory() -&gt; refreshBeanFactory() -&gt; loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 12345678910111213141516171819202122232425262728293031323334353637383940// AbstractXmlApplicationContext.java@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // 创建 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 传入ResourceLoader beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125;protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; // 获取容器启动时，传入的资源文件路径 String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125;// AbstractBeanDefinitionReader.javapublic int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; ResourceLoader resourceLoader = getResourceLoader(); //..........此处省略部分源码 if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; // 这里才是真正将 资源路径 解析为Resource的地方 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); //..........此处省略部分源码 &#125; &#125; //..........此处省略部分源码&#125; 从上面可以看出，AbstractXmlApplicationContext 将Bean的装载任务委派给了XmlBeanDefinitionReader, 而ResourceLoader负责将xml解析为Resource。 先看看类结构图 从上面可以看到，Spring为了统一不同类型的资源访问，把所有资源都抽象成Resource接口, 屏蔽不同资源之间的差异，其实现了InputStreamSource, 这样所有Resource都可以通过getInputStream()获取InputStream。 其中资源定位路径 -&gt; Resource 这个过程是由 ResourceLoader 这个类来完成的，我们暂且称之为: 资源定位器, 其默认实现是 DefaultResourceLoader。 ResourcePatternResolver 继承自 ResourceResolver ，扩展了一个能通过路径模式匹配定位的方法： Resource[] getResources(String locationPattern)，其路径模式支持以 classpath / classpath* 或 URI协议名（例如 http、file、jar:file）为其前缀，还支持 Ant风格 的匹配模式。 看看 ResourcePatternResolver 的实现类 PathMatchingResourcePatternResolver 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 构造方法创建的 DefaultResourceLoaderprivate final ResourceLoader resourceLoader;// Ant风格 路径匹配器private PathMatcher pathMatcher = new AntPathMatcher();public Resource[] getResources(String locationPattern) throws IOException &#123; if (locationPattern.startsWith(&quot;classpath*:&quot;)) &#123; // &quot;classpath*:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式 if (getPathMatcher().isPattern(locationPattern.substring(&quot;classpath*:&quot;.length()))) &#123; // eg: classpath*:a/b/applicationContext-*.xml // 根据路径模式 查找所有匹配的资源 return findPathMatchingResources(locationPattern); &#125; else &#123; // eg: classpath*:a/b/applicationContext-dao.xml 或 classpath*:a/b/ // 根据确定路径 在所有classpath中(包含所有jar包)查找资源 return findAllClassPathResources(locationPattern.substring(&quot;classpath*:&quot;.length())); &#125; &#125; else &#123; // 第一个 &quot;:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式 int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1; if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // 根据路径模式 查找所有匹配的资源 return findPathMatchingResources(locationPattern); &#125; else &#123; // 加载单个资源，后面再详细讲讲 getResource 这个方法 return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125;// 根据路径模式 查找所有匹配的资源protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; // 获取到一个不含通配符的根目录，如 classpath*:a/b/*/applicationContext-*.xml 返回 classpath*:a/b/ String rootDirPath = determineRootDir(locationPattern); // 返回 */applicationContext-*.xml String subPattern = locationPattern.substring(rootDirPath.length()); // 递归调用getResources(), 获取的符合根目录的所有资源 Resource[] rootDirResources = getResources(rootDirPath); Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(16); // 遍历根目录资源，将匹配的资源添加到 result 中 for (Resource rootDirResource : rootDirResources) &#123; // jar:file:开头的为jar包资源 if (isJarResource(rootDirResource)) &#123; result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern)); &#125; else if (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirResource, subPattern, getPathMatcher())); &#125; else &#123; // 其他类型资源走这里 result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; return result.toArray(new Resource[result.size()]);&#125;protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern) throws IOException &#123; File rootDir = rootDirResource.getFile().getAbsoluteFile(); //..........此处省略部分源码 return doFindMatchingFileSystemResources(rootDir, subPattern);&#125;protected Set&lt;Resource&gt; doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException &#123; // retrieveMatchingFiles 流程比较长就不贴出来了，有兴趣的朋友可以debug进去看看 Set&lt;File&gt; matchingFiles = retrieveMatchingFiles(rootDir, subPattern); Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(matchingFiles.size()); for (File file : matchingFiles) &#123; // 符合条件的路径 此时就解析为Resource了 result.add(new FileSystemResource(file)); &#125; return result;&#125; 上面就是PathMatchingResourcePatternResolver路径模式匹配的基本逻辑。加载单个资源的任务是委托给了构造方法里面创建的 DefaultResourceLoader DefaultResourceLoader 如下 1234567891011121314151617181920public Resource getResource(String location) &#123; // 以 classpath: 开头的返回 ClassPathResource if (location.startsWith(&quot;classpath:&quot;)) &#123; return new ClassPathResource(location.substring(&quot;classpath:&quot;.length()), getClassLoader()); &#125; else &#123; try &#123; // 能够解析为URL的返回 UrlResource URL url = new URL(location); return new UrlResource(url); &#125; catch (MalformedURLException ex) &#123; // 不能够解析为URL的 由getResourceByPath返回 return getResourceByPath(location); &#125; &#125;&#125;protected Resource getResourceByPath(String path) &#123; // 默认返回 ClassPathContextResource return new ClassPathContextResource(path, getClassLoader());&#125; 从上面的类结构图，我们看到 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 都是 DefaultResourceLoader 的子类，区别在于前者重写了 getResourceByPath 方法 123456protected Resource getResourceByPath(String path) &#123; if (path != null &amp;&amp; path.startsWith(&quot;/&quot;)) &#123; path = path.substring(1); &#125; return new FileSystemResource(path);&#125; 那么 不带前缀的 路径或者 自定义前缀 的路径能否定位成功，关键在于getResourceByPath方法了，回到文章开始 传入的路径: applicationContext.xml 和 E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml 走的是 DefaultResourceLoader 默认的 getResourceByPath方法，返回的classpath里面的资源，所以后者在ClassPathXmlApplicationContext里面是启动不了的，反之前者在FileSystemXmlApplicationContext也启动不了 classpath:applicationContext.xml 和 file:E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml 都带有前缀，所以跟getResourceByPath无关，也就是跟 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 无关，传入哪个Context都能启动成功 总结起来, Spring的资源路径填写方式如下： 前缀 示例 说明 classpath: classpath:a/c.xml 从classpath中加载，存在多个资源则返回最先加载的那个资源，易导致资源加载不进来的问题 classpath*: classpath*:a/c.xml 从classpath中加载，返回全部符合条件的资源，需要遍历所有classpath, 因此加载效率低 file: 或 jar:file: 等URI协议名 file:d:\\b\\f.xml 作为URL进行加载 没有前缀 a/c.xml 或 d:\\b\\f.xml 根据context的getResourceByPath方法判断 Ant风格 的匹配模式 “ ? ”：匹配一个字符, 如 a?.xml 匹配 ab.xml “ * ”：匹配零个或多个字符串，如“a/ * /c.xml”将匹配“a/b/c.xml”，但不匹配匹配“a/c.xml”；而“a/c-*.xml”将匹配“a/c-dao.xml” “ ** ”：匹配路径中的零个或多个目录，如“a/ ** /c.xml”将匹配“a /c.xml”，也匹配“a/b/b/c.xml”；而“a/b/c- ** .xml”将匹配“a/b/c-dao.xml”，即把“ ** ”当做两个“ * ”处理。 这就是Spring容器中资源的定位，然后通过 Resource 的 getInputStream() 加载进内存进行解析，至于如何解析，就请听下回分解啦。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"如何手动启动Spring容器","slug":"spring-startup-java","date":"2019-10-12T15:12:02.000Z","updated":"2019-10-17T08:33:57.821Z","comments":true,"path":"2019/10/12/spring-startup-java/","link":"","permalink":"http://me.oopcoder.cn/2019/10/12/spring-startup-java/","excerpt":"","text":"工作中，我想大家最熟悉的Spring容器启动方法，就是在web环境下，通过在web.xml中配置如下代码进行启动。 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 那么，离开了web环境，想单独的启动一个Spring容器该怎么做呢，其实也很简单，有两种方式，直接看代码： 1. 手动启动目录结构： pom.xml 123456789101112131415161718192021222324252627282930&lt;properties&gt; &lt;spring.version&gt;3.0.0.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring单元测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; applicationContext.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;helloWorld-id&quot; name=&quot;helloWorld&quot; class=&quot;com.bing.lan.spring.HelloWorld&quot;/&gt; &lt;/beans&gt; 日志配置： logback.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration debug=&quot;true&quot;&gt; &lt;contextName&gt;spring&lt;/contextName&gt; &lt;property name=&quot;NORMAL_PATTERN&quot; value=&quot; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level - %logger&#123;100&#125; - %msg%n&quot;/&gt; &lt;Appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;Layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt;$&#123;NORMAL_PATTERN&#125;&lt;/Pattern&gt; &lt;/Layout&gt; &lt;/Appender&gt; &lt;ROOT level=&quot;DEBUG&quot;&gt; &lt;Appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;/ROOT&gt;&lt;/Configuration&gt; HelloWorld.java 1234567891011public class HelloWorld &#123; private String name = &quot;OOPcoder&quot;; @Override public String toString() &#123; return &quot;HelloWorld&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; SpringStartup.java 123456789101112131415package com.bing.lan.spring;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringStartup &#123; public static void main(String[] args) &#123; // 手动启动spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); HelloWorld helloWorld = (HelloWorld) context.getBean(&quot;helloWorld&quot;); System.out.println(&quot;main(): &quot; + helloWorld); &#125;&#125; 启动main函数，容器就启动了。 2. 通过 junit 来启动在上面这些类的基础上再添加一个测试类 SpringTest.java 1234567891011121314151617181920212223242526272829package com.bing.lan.spring;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class SpringTest &#123; @Autowired BeanFactory beanFactory; @Autowired ApplicationContext applicationContext; @Test public void test() &#123; HelloWorld helloWorld = (HelloWorld) applicationContext.getBean(&quot;helloWorld&quot;); System.out.println(&quot;main(): &quot; + helloWorld); helloWorld = (HelloWorld) beanFactory.getBean(&quot;helloWorld&quot;); System.out.println(&quot;main(): &quot; + helloWorld); &#125;&#125; 运行test()，容器启动成功。 学会了怎么启动，有啥好处呢，好处很多，比如 可以脱离web环境测试我们的 service / mapper 层，极大的提高开发效率； 还可以debug进Spring源码里学习各种原理，这对我们小白来说，是非常友好的，因为这只是一个单纯的Spring, 没有其他框架的干扰。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"内嵌iframe实现html页面轮播","slug":"html-swiper-iframe","date":"2019-08-06T11:52:39.000Z","updated":"2019-08-09T08:33:13.445Z","comments":true,"path":"2019/08/06/html-swiper-iframe/","link":"","permalink":"http://me.oopcoder.cn/2019/08/06/html-swiper-iframe/","excerpt":"","text":"需求是这样的，我们的产品要在某个展厅中展示，主办方要求我们提供部分系统界面在电视上作为宣传页，时间紧迫，已经来不及开发了，我就在想，能不能轮播我们系统已经存在的页面（哈哈，我是有多么懒），省心省力，想法虽好，但是作为一个前端白痴 ( 没怎么写过前端代码，轮播图都没实现过 )，对我来说还是有难度的啊~~ 但是没办法，自己提出来的想法，含着泪也得实现。 经过一天的查资料，终于实现了，实现后发现原来这么简单，下面把代码贴出来，鼓励自己继续学习前端。 代码是jsp写的，用在html的话改改就可以了 轮播控件用的是 swiper , 然后用iframe实现网页内嵌 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@page import=&quot;java.util.Calendar&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;&lt;c:set var=&quot;ctx&quot; value=&quot;$&#123;pageContext.request.contextPath&#125;&quot;/&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Swiper demo&lt;/title&gt; &lt;!-- Link Swiper&apos;s CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;ctx&#125;/static/swiper/css/swiper.min.css&quot;&gt; &lt;!-- Demo styles --&gt; &lt;style&gt; html, body &#123; position: relative; height: 100%; &#125; body &#123; background: #eee; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14px; color: #000; margin: 0; padding: 0; &#125; .swiper-container &#123; width: 100%; height: 100%; &#125; .swiper-slide &#123; text-align: center; font-size: 18px; background: #fff; /* Center slide text vertically */ display: -webkit-box; display: -ms-flexbox; display: -webkit-flex; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center; justify-content: center; -webkit-box-align: center; -ms-flex-align: center; -webkit-align-items: center; align-items: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- Swiper --&gt;&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;!-- url1,url2,url3,url4 替换成网页地址，注意跨域问题--&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url1&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url2&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url3&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url4&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- Swiper JS --&gt;&lt;script src=&quot;$&#123;ctx&#125;/static/swiper/js/swiper.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;ctx&#125;/static/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- Initialize Swiper --&gt;&lt;script var swiper = new Swiper(&apos;.swiper-container&apos;, &#123; loop: true, autoplay: &#123; delay: 10000//10秒切换一次 // stopOnLastSlide: false, // disableOnInteraction: true &#125;, //开启循环 speed: 2000, // 如果需要前进后退按钮 navigation: &#123; nextEl: &apos;.swiper-button-next&apos;, prevEl: &apos;.swiper-button-prev&apos; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"html","slug":"html","permalink":"http://me.oopcoder.cn/blog/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://me.oopcoder.cn/blog/tags/html/"},{"name":"iframe","slug":"iframe","permalink":"http://me.oopcoder.cn/blog/tags/iframe/"},{"name":"banner","slug":"banner","permalink":"http://me.oopcoder.cn/blog/tags/banner/"},{"name":"swiper","slug":"swiper","permalink":"http://me.oopcoder.cn/blog/tags/swiper/"}]},{"title":"Linux命令行样式定制","slug":"linux-xshell-css","date":"2019-08-05T13:53:02.000Z","updated":"2019-08-09T08:33:13.447Z","comments":true,"path":"2019/08/05/linux-xshell-css/","link":"","permalink":"http://me.oopcoder.cn/2019/08/05/linux-xshell-css/","excerpt":"","text":"在使用linux命令行时候，总是难以区分命令和结果的具体界线，不知道当前的路径在哪里，就像下面这样，无形之中降低了我们的效率。但是我们在用git bash的时候不会有这个烦恼，那我们能不能将linux中的界面样式定制一下，变成git bash这样呢？答案是肯定的。 linux命令行界面 git bash 界面 通过查资料发现，要想修改命令行头部显示样式，实际的操作就是覆盖系统本身的 PS1 变量，如下代码所示，在当前用户(这里是root用户)的./bashrc中添加 PS1 的值就可以了 12345678910111213141516[root@VM_72_235_centos ~]# vi .bashrc[root@VM_72_235_centos ~]# cat .bashrc# .bashrc# User specific aliases and functionsalias rm=&apos;rm -i&apos;alias cp=&apos;cp -i&apos;alias mv=&apos;mv -i&apos;# Source global definitionsif [ -f /etc/bashrc ]; then . /etc/bashrcfi# 添加这行就可以了PS1=&apos;[\\[\\e[00;35m\\]\\u@dev \\t\\[\\e[0m\\]]\\[\\e[0;33m\\](\\w)\\$\\[\\e[0m\\] &apos;[root@VM_72_235_centos ~]# source .bashrc (执行这句设置生效，只对当前用户生效)[root@dev 22:36:51](~)# ls (发现生效了) 先将这行代码拆分如下，再来分析具体意思 12345 [ //表示【 [ 】 颜色为 默认颜色\\[\\e[00;35m\\] \\u@dev \\t //表示【 \\u@dev \\t 】 颜色为 【 \\[\\e[00;35m\\] 】\\[\\e[0m\\] ] //表示【 ] 】 颜色为 【 \\[\\e[0m\\] 】\\[\\e[0;33m\\] (\\w)\\$ //表示【 (\\w)\\$ 】 颜色为 【 \\[\\e[0;33m\\] 】\\[\\e[0m\\] //取消设置(设置回默认颜色) [\\e[00;35m] 该设置是应用到后面字符上，直到有其他设置，所以最后要设置回默认颜色 设置字符序列颜色的格式为：[\\e[F;Bm] 其中“F”为字体颜色，编号30 ~ 37；“B”为背景色，编号40 ~ 47 颜色表前景 | 背景 | 颜色—|—|—30 | 40 | 黑色31 | 41 | 红色32 | 42 | 绿色33 | 43 | 黄色34 | 44 | 蓝色35 | 45 | 紫红色36 | 46 | 青蓝色37 | 47 | 白色 变量值： \\d ：可显示出『星期 月 日』的日期格式，如：”Mon Feb 2” \\H ：完整的主机名称。举例来说，鸟哥的练习机为『www.vbird.tsai』 \\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略 \\t ：显示时间，为 24 小时格式的『HH:MM:SS』 \\T ：显示时间，为 12 小时格式的『HH:MM:SS』 \\A ：显示时间，为 24 小时格式的『HH:MM』 @ ：显示时间，为 12 小时格式的『am/pm』样式 \\u ：目前使用者的帐号名称，如『root』； \\v ：BASH 的版本资讯，如鸟哥的测试主机版本为 3.2.25(1)，仅取『3.2』显示 \\w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代； \\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。 # ：下达的第几个指令。 $ ：提示字元，如果是 root 时，提示字元为 # ，否则就是 $ \\n : new line,表示另起一行显示指令符 通过上面的颜色及变量值对照表，就可以轻松的定制出适合自己的样式啦。 我的配置如下，跟git bash相近 12345PS1=&apos;\\[\\e[00;35m\\]\\u@\\h \\t \\[\\e[0;33m\\]\\w (12.22.34.179)\\n\\$\\[\\e[0m\\] &apos; 效果如下(颜色在这里没显示出来)：root@VM_72_235_centos 21:22:43 /usr/local/share (12.22.34.179)$ less log.log 参考：在xshell中将命令行移至下一行: http://blog.sina.com.cn/s/blog_96a11ddf0102vbb7.html","categories":[{"name":"linux","slug":"linux","permalink":"http://me.oopcoder.cn/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://me.oopcoder.cn/blog/tags/linux/"},{"name":"xshell","slug":"xshell","permalink":"http://me.oopcoder.cn/blog/tags/xshell/"}]},{"title":"为什么有时候maven无法更新jar包","slug":"maven-lastupdated","date":"2019-08-04T05:20:02.000Z","updated":"2019-08-05T01:24:58.327Z","comments":true,"path":"2019/08/04/maven-lastupdated/","link":"","permalink":"http://me.oopcoder.cn/2019/08/04/maven-lastupdated/","excerpt":"","text":"在使用maven管理pom项目的时候，多多少少会遇到一些奇葩的问题，比如网络良好，idea非离线状态，科学上网模式，maven就是死活无法更新jar包，很令人头大，无从下手找原因，当我们去查看maven本地仓库的时候，发现有些包里会多了一些以 .lastUpdated 结尾的文件，那么问题来了 为什么maven仓库会出现这些文件? 又会导致什么问题? 在idea网络状态很差或者离线状态时，需要从远程仓库下载某些jar包到本地参库时，因网络差，无法下载，导致本地仓库出现 xx.jar.lastUpdated 或者 xx.pom.lastUpdated 文件(文件具体作用暂时不清楚)， 由于这些文件的存在，即使网络变好后，项目仍然报错， 无法重新下载需要的jar包 解决方法: 方法非常简单粗暴，找到本地仓库对应jar包目录位置将 .lastUpdated 文件删除, 刷新项目重新下载即可 有的小伙伴可能会问，仓库那么多，总不会让我一个个找到然后删除吧，机智，下面给大家提供了两个一键删除脚本： 1、cleanLastUpdated.bat（windows版本）123456789rem 这里写你的仓库路径set REPOSITORY_PATH=D:\\Java\\maven-repositoryrem 正在搜索...for /f &quot;delims=&quot; %%i in (&apos;dir /b /s &quot;%REPOSITORY_PATH%\\*lastUpdated*&quot;&apos;) do ( echo %%i del /s /q &quot;%%i&quot;)rem 搜索完毕pause 2、cleanLastUpdated.sh（linux版本）12345# 这里写你的仓库路径REPOSITORY_PATH=~/Documents/tools/repositoryecho 正在搜索...find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; | xargs rm -frecho 搜索完 参考：maven仓库中的LastUpdated文件生成原因及删除","categories":[{"name":"maven","slug":"maven","permalink":"http://me.oopcoder.cn/blog/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://me.oopcoder.cn/blog/tags/maven/"},{"name":"pom","slug":"pom","permalink":"http://me.oopcoder.cn/blog/tags/pom/"}]},{"title":"Hexo 博客搭建（一）","slug":"hexo-blog-create","date":"2019-08-02T07:20:02.000Z","updated":"2019-08-05T01:24:58.326Z","comments":true,"path":"2019/08/02/hexo-blog-create/","link":"","permalink":"http://me.oopcoder.cn/2019/08/02/hexo-blog-create/","excerpt":"","text":"网上学习搭建hexo博客的教程一抓一大把，但是基本上都没说清楚这中间的原理到底是啥？那么让我带领大家一起去探个究竟，学习之前，我们先看看 Github Pages (以下简称 gp) 和 Hexo 到底是什么？ 1. 什么是Github Pages?官方文档是这样描述的： 1GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository. 好了，文档看完了，接下来可以愉快的创建一个属于自己的博客了，我先假设：你已经有了GitHub的账号，并且账号是 AAA， 首先 我们创建一个 名称为 AAA.github.io (名称必须按这个格式)的git仓库，如下图： 然后，在浏览器中输入 http://AAA.github.io 看到如上界面，说明我们的最简单的 github博客已经搭建完成啦~ 2. 什么是 Hexo?Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官方文档 点这查看 看到这里，可能还是一脸懵逼，不过我们需要知道 gp 和 hexo 之间的联系，在我看来, 他们之间其实没有任何关系，唯一的联系是： github 会托管静态网页，而 hexo 会生成静态网页，我们只是将hexo生成的网页放到 github上，这样访问 AAA.github.io 就访问了hexo生成的网页 这关系一下子就清楚了，接下来继续。。 3. 环境 Node.js / Git 安装来到这步，说明你已经了解了上述的概念 主要流程： 安装 git 安装 node node安装好之后，安装 hexo 安装细节的话，我们还是按照官方文档进行 坑：1.执行 npm install -g hexo-cli 长时间无响应，或者报如下错 1234567$ npm install -g hexo-clinpm ERR! code EAI_AGAINnpm ERR! errno EAI_AGAINnpm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: getaddrinfo EAI_AGAIN registry.npmjs.org:443npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\lanbing\\AppData\\Roaming\\npm-cache\\_logs\\2018-03-13T02_15_13_203Z-debug.log 解决办法：执行 $ npm install -g npm 更新 npm , 然后再次执行 $ npm install -g hexo-cli 1234567891011$ npm install -g npmC:\\Users\\lanbing\\AppData\\Roaming\\npm\\npm -&gt; C:\\Users\\lanbing\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.jsC:\\Users\\lanbing\\AppData\\Roaming\\npm\\npx -&gt; C:\\Users\\lanbing\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npx-cli.jsnpm@5.7.1added 533 packages in 113.185sC:\\Users\\lanbing\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\lanbing\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\bin\\hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\\hexo-cli\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)hexo-cli@1.1.0added 103 packages from 338 contributors in 73.08s 4.Hexo博客搭建踩过一系列的坑之后，现在终于可以开始搭建 hexo blog了 新建一个文件夹叫 helloBlog (可自己随便取名字，无所谓) 进入文件夹 helloBlog 中， 在 git bash 窗口里面执行下面命令初始化博客 12$ hexo init $ npm install //这条命令不执行，貌似也可以，不过官方文档写明要执行，那就执行吧 执行完命令后，文件夹目录如下表示初始化成功 12345678 .├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 博客已经构建好了，现在需要的是一个本地服务器来进行部署，Hexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用， 用如下命令安装： 1$ npm install hexo-server --save 现在启动服务器 12345$ hexo s //或者 hexo server// 出现如下信息，表明已经成功启动了服务器$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 现在在浏览器中输入 http://localhost:4000/或者 http://127.0.0.1:4000/（有的电脑，输入localhost访问不了，就用 127.0.0.1 访问）就可以访问啦~~ 到目前为止，我们知道了在怎么样利用 github 和 hexo 搭建博客, 但是要怎么实现上面说的，将 hexo 生成的静态博客网页，放到 github 中进行托管？就等下一篇文章再给大家讲解啦！！","categories":[{"name":"hexo","slug":"hexo","permalink":"http://me.oopcoder.cn/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://me.oopcoder.cn/blog/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-02T07:10:02.000Z","updated":"2019-08-05T01:24:58.324Z","comments":true,"path":"2019/08/02/hello-world/","link":"","permalink":"http://me.oopcoder.cn/2019/08/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}