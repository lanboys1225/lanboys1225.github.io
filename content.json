{"meta":{"title":"OOPcoder","subtitle":null,"description":null,"author":"lanboys1225","url":"http://me.oopcoder.cn","root":"/"},"pages":[{"title":"关于","date":"2019-08-10T09:19:05.070Z","updated":"2019-08-10T09:19:05.070Z","comments":true,"path":"about/index.html","permalink":"http://me.oopcoder.cn/about/index.html","excerpt":"","text":"这是我的个人博客项目，里面会记录生活和技术的点点滴滴。 访问地址：https://me.oopcoder.cn 我的微信公众号 OOPcoder 欢迎留言～"},{"title":"我的朋友们","date":"2019-08-05T07:45:07.344Z","updated":"2019-08-05T07:45:07.344Z","comments":true,"path":"friends/index.html","permalink":"http://me.oopcoder.cn/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： OOPcoder头像： https://me.oopcoder.cn/assets/images/oopcoder.jpg网址： https://me.oopcoder.cn标签： Java"},{"title":"所有分类","date":"2019-08-03T08:47:32.659Z","updated":"2019-08-01T07:42:58.161Z","comments":true,"path":"blog/categories/index.html","permalink":"http://me.oopcoder.cn/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-08-03T09:23:15.295Z","updated":"2019-08-03T09:23:15.295Z","comments":true,"path":"blog/tags/index.html","permalink":"http://me.oopcoder.cn/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring容器加载过程源码解析之Resource定位加载","slug":"spring-resource-load","date":"2019-10-18T07:03:02.000Z","updated":"2019-10-18T09:22:25.801Z","comments":true,"path":"2019/10/18/spring-resource-load/","link":"","permalink":"http://me.oopcoder.cn/2019/10/18/spring-resource-load/","excerpt":"","text":"在上文 如何手动启动Spring容器 中，我们知道了可以通过传入资源文件来启动容器，如果将applicationContext.xml替换为绝对路径就启动不了，报错。 12345678910111213141516171819//启动容器ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)//更换为绝对路径，启动失败ApplicationContext context = new ClassPathXmlApplicationContext( &quot;E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;);//报 FileNotFoundException：Caused by: java.io.FileNotFoundException: class path resource [E:/IDEA_workspace/SpringLearningDemo/spring-java/src/main/resources/applicationContext.xml] cannot be opened because it does not exist//使用 FileSystemXmlApplicationContext 正常启动ApplicationContext context = new FileSystemXmlApplicationContext( &quot;E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;); // 启动成功ApplicationContext context = new FileSystemXmlApplicationContext( &quot;classpath:applicationContext.xml&quot;);// 启动成功 ApplicationContext context = new ClassPathXmlApplicationContext( &quot;file:E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;); 通过字面意思，可以看出ClassPathXmlApplicationContext, 传入的是classpath目录下的资源文件, FileSystemXmlApplicationContext, 传入的是文件系统下资源文件(即文件绝对路径), 我们在资源文件前面加上 classpath 或 file，启动试试，发现也都成功了，看来资源的定位没有上面说的那么简单，还跟资源路径前缀有关。 提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了 下面带着疑问来看看Spring资源到底是怎么定位和加载进来的。进入ClassPathXmlApplicationContext源码，按下面路径走, 找到getResources方法： refresh() -&gt; obtainFreshBeanFactory() -&gt; refreshBeanFactory() -&gt; loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 12345678910111213141516171819202122232425262728293031323334353637383940 // AbstractXmlApplicationContext.java @Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // 创建 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 传入ResourceLoader beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125;protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; // 获取容器启动时，传入的资源文件路径 String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125;// AbstractBeanDefinitionReader.javapublic int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; ResourceLoader resourceLoader = getResourceLoader(); //..........此处省略部分源码 if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; // 这里才是真正将 资源路径 解析为Resource的地方 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); //..........此处省略部分源码 &#125; &#125; //..........此处省略部分源码&#125; 从上面可以看出，AbstractXmlApplicationContext 将Bean的装载任务委派给了XmlBeanDefinitionReader, 而ResourceLoader负责将xml解析为Resource。 先看看类结构图 从上面可以看到，Spring为了统一不同类型的资源访问，把所有资源都抽象成Resource接口, 屏蔽不同资源之间的差异，其实现了InputStreamSource, 这样所有Resource都可以通过getInputStream()获取InputStream。 其中资源定位路径 --&gt; Resource 这个过程是由 ResourceLoader 这个类来完成的，我们暂且称之为: 资源定位器, 其默认实现是 DefaultResourceLoader。 ResourcePatternResolver 继承自 ResourceResolver ，扩展了一个能通过路径模式匹配定位的方法： Resource[] getResources(String locationPattern)，其路径模式支持以 classpath / classpath* 或 URI协议名（例如 http、file、jar:file）为其前缀，还支持 Ant风格 的匹配模式。 看看 ResourcePatternResolver 的实现类 PathMatchingResourcePatternResolver 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 // 构造方法创建的 DefaultResourceLoader private final ResourceLoader resourceLoader; // Ant风格 路径匹配器private PathMatcher pathMatcher = new AntPathMatcher();public Resource[] getResources(String locationPattern) throws IOException &#123; if (locationPattern.startsWith(&quot;classpath*:&quot;)) &#123; // &quot;classpath*:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式 if (getPathMatcher().isPattern(locationPattern.substring(&quot;classpath*:&quot;.length()))) &#123; // eg: classpath*:a/b/applicationContext-*.xml // 根据路径模式 查找所有匹配的资源 return findPathMatchingResources(locationPattern); &#125; else &#123; // eg: classpath*:a/b/applicationContext-dao.xml 或 classpath*:a/b/ // 根据确定路径 在所有classpath中(包含所有jar包)查找资源 return findAllClassPathResources(locationPattern.substring(&quot;classpath*:&quot;.length())); &#125; &#125; else &#123; // 第一个 &quot;:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式 int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1; if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // 根据路径模式 查找所有匹配的资源 return findPathMatchingResources(locationPattern); &#125; else &#123; // 加载单个资源，后面再详细讲讲 getResource 这个方法 return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125;// 根据路径模式 查找所有匹配的资源protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; // 获取到一个不含通配符的根目录，如 classpath*:a/b/*/applicationContext-*.xml 返回 classpath*:a/b/ String rootDirPath = determineRootDir(locationPattern); // 返回 */applicationContext-*.xml String subPattern = locationPattern.substring(rootDirPath.length()); // 递归调用getResources(), 获取的符合根目录的所有资源 Resource[] rootDirResources = getResources(rootDirPath); Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(16); // 遍历根目录资源，将匹配的资源添加到 result 中 for (Resource rootDirResource : rootDirResources) &#123; // jar:file:开头的为jar包资源 if (isJarResource(rootDirResource)) &#123; result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern)); &#125; else if (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirResource, subPattern, getPathMatcher())); &#125; else &#123; // 其他类型资源走这里 result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; return result.toArray(new Resource[result.size()]);&#125;protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern) throws IOException &#123; File rootDir = rootDirResource.getFile().getAbsoluteFile(); //..........此处省略部分源码 return doFindMatchingFileSystemResources(rootDir, subPattern);&#125;protected Set&lt;Resource&gt; doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException &#123; // retrieveMatchingFiles 流程比较长就不贴出来了，有兴趣的朋友可以debug进去看看 Set&lt;File&gt; matchingFiles = retrieveMatchingFiles(rootDir, subPattern); Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(matchingFiles.size()); for (File file : matchingFiles) &#123; // 符合条件的路径 此时就解析为Resource了 result.add(new FileSystemResource(file)); &#125; return result;&#125; 上面就是PathMatchingResourcePatternResolver路径模式匹配的基本逻辑。加载单个资源的任务是委托给了构造方法里面创建的 DefaultResourceLoader DefaultResourceLoader 1234567891011121314151617181920public Resource getResource(String location) &#123; // 以 classpath: 开头的返回 ClassPathResource if (location.startsWith(&quot;classpath:&quot;)) &#123; return new ClassPathResource(location.substring(&quot;classpath:&quot;.length()), getClassLoader()); &#125; else &#123; try &#123; // 能够解析为URL的返回 UrlResource URL url = new URL(location); return new UrlResource(url); &#125; catch (MalformedURLException ex) &#123; // 不能够解析为URL的 由getResourceByPath返回 return getResourceByPath(location); &#125; &#125;&#125;protected Resource getResourceByPath(String path) &#123; // 默认返回 ClassPathContextResource return new ClassPathContextResource(path, getClassLoader());&#125; 从上面的类结构图，我们看到 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 都是 DefaultResourceLoader 的子类，区别在于前者重写了 getResourceByPath 方法 123456protected Resource getResourceByPath(String path) &#123; if (path != null &amp;&amp; path.startsWith(&quot;/&quot;)) &#123; path = path.substring(1); &#125; return new FileSystemResource(path);&#125; 那么 不带前缀的 路径或者 自定义前缀 的路径能否定位成功，关键在于getResourceByPath方法了，回到文章开始 传入的路径: applicationContext.xml 和 E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml 走的是 DefaultResourceLoader 默认的 getResourceByPath方法，返回的classpath里面的资源，所以后者在ClassPathXmlApplicationContext里面是启动不了的，反之前者在FileSystemXmlApplicationContext也启动不了 classpath:applicationContext.xml 和 file:E:\\\\IDEA_workspace\\\\SpringLearningDemo\\\\spring-java\\\\src\\\\main\\\\resources\\\\applicationContext.xml 都带有前缀，所以跟getResourceByPath无关，也就是跟 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 无关，传入哪个Context都能启动成功 总结起来, Spring的资源路径填写方式如下： 前缀 示例 说明 classpath: classpath:a/c.xml 从classpath中加载，存在多个资源则返回最先加载的那个资源，易导致资源加载不进来的问题 classpath*: classpath*:a/c.xml 从classpath中加载，返回全部符合条件的资源，需要遍历所有classpath, 因此加载效率低 file: 或 jar:file: 等URI协议名 file:d:\\b\\f.xml 作为URL进行加载 没有前缀 a/c.xml 或 d:\\b\\f.xml 根据context的getResourceByPath方法判断 Ant风格 的匹配模式 “ ? ”：匹配一个字符, 如 a?.xml 匹配 ab.xml “ * ”：匹配零个或多个字符串，如“a/ * /c.xml”将匹配“a/b/c.xml”，但不匹配匹配“a/c.xml”；而“a/c-*.xml”将匹配“a/c-dao.xml” “ ** ”：匹配路径中的零个或多个目录，如“a/ ** /c.xml”将匹配“a /c.xml”，也匹配“a/b/b/c.xml”；而“a/b/c- ** .xml”将匹配“a/b/c-dao.xml”，即把“ ** ”当做两个“ * ”处理。 这就是Spring容器中资源的定位，然后通过 Resource 的 getInputStream() 加载进内存进行解析，至于如何解析，就请听下回分解啦。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"如何手动启动Spring容器","slug":"spring-startup-java","date":"2019-10-12T15:12:02.000Z","updated":"2019-10-17T08:33:57.821Z","comments":true,"path":"2019/10/12/spring-startup-java/","link":"","permalink":"http://me.oopcoder.cn/2019/10/12/spring-startup-java/","excerpt":"","text":"工作中，我想大家最熟悉的Spring容器启动方法，就是在web环境下，通过在web.xml中配置如下代码进行启动。 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 那么，离开了web环境，想单独的启动一个Spring容器该怎么做呢，其实也很简单，有两种方式，直接看代码： 1. 手动启动目录结构： pom.xml 123456789101112131415161718192021222324252627282930&lt;properties&gt; &lt;spring.version&gt;3.0.0.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring单元测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; applicationContext.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;helloWorld-id&quot; name=&quot;helloWorld&quot; class=&quot;com.bing.lan.spring.HelloWorld&quot;/&gt; &lt;/beans&gt; 日志配置： logback.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration debug=&quot;true&quot;&gt; &lt;contextName&gt;spring&lt;/contextName&gt; &lt;property name=&quot;NORMAL_PATTERN&quot; value=&quot; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level - %logger&#123;100&#125; - %msg%n&quot;/&gt; &lt;Appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;Layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt;$&#123;NORMAL_PATTERN&#125;&lt;/Pattern&gt; &lt;/Layout&gt; &lt;/Appender&gt; &lt;ROOT level=&quot;DEBUG&quot;&gt; &lt;Appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;/ROOT&gt;&lt;/Configuration&gt; HelloWorld.java 1234567891011public class HelloWorld &#123; private String name = &quot;OOPcoder&quot;; @Override public String toString() &#123; return &quot;HelloWorld&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; SpringStartup.java 123456789101112131415package com.bing.lan.spring;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringStartup &#123; public static void main(String[] args) &#123; // 手动启动spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); HelloWorld helloWorld = (HelloWorld) context.getBean(&quot;helloWorld&quot;); System.out.println(&quot;main(): &quot; + helloWorld); &#125;&#125; 启动main函数，容器就启动了。 2. 通过 junit 来启动在上面这些类的基础上再添加一个测试类 SpringTest.java 1234567891011121314151617181920212223242526272829package com.bing.lan.spring;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class SpringTest &#123; @Autowired BeanFactory beanFactory; @Autowired ApplicationContext applicationContext; @Test public void test() &#123; HelloWorld helloWorld = (HelloWorld) applicationContext.getBean(&quot;helloWorld&quot;); System.out.println(&quot;main(): &quot; + helloWorld); helloWorld = (HelloWorld) beanFactory.getBean(&quot;helloWorld&quot;); System.out.println(&quot;main(): &quot; + helloWorld); &#125;&#125; 运行test()，容器启动成功。 学会了怎么启动，有啥好处呢，好处很多，比如 可以脱离web环境测试我们的 service / mapper 层，极大的提高开发效率； 还可以debug进Spring源码里学习各种原理，这对我们小白来说，是非常友好的，因为这只是一个单纯的Spring, 没有其他框架的干扰。","categories":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://me.oopcoder.cn/blog/tags/spring/"}]},{"title":"内嵌iframe实现html页面轮播","slug":"html-swiper-iframe","date":"2019-08-06T11:52:39.000Z","updated":"2019-08-09T08:33:13.445Z","comments":true,"path":"2019/08/06/html-swiper-iframe/","link":"","permalink":"http://me.oopcoder.cn/2019/08/06/html-swiper-iframe/","excerpt":"","text":"需求是这样的，我们的产品要在某个展厅中展示，主办方要求我们提供部分系统界面在电视上作为宣传页，时间紧迫，已经来不及开发了，我就在想，能不能轮播我们系统已经存在的页面（哈哈，我是有多么懒），省心省力，想法虽好，但是作为一个前端白痴 ( 没怎么写过前端代码，轮播图都没实现过 )，对我来说还是有难度的啊~~ 但是没办法，自己提出来的想法，含着泪也得实现。 经过一天的查资料，终于实现了，实现后发现原来这么简单，下面把代码贴出来，鼓励自己继续学习前端。 代码是jsp写的，用在html的话改改就可以了 轮播控件用的是 swiper , 然后用iframe实现网页内嵌 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@page import=&quot;java.util.Calendar&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;&lt;c:set var=&quot;ctx&quot; value=&quot;$&#123;pageContext.request.contextPath&#125;&quot;/&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Swiper demo&lt;/title&gt; &lt;!-- Link Swiper&apos;s CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;ctx&#125;/static/swiper/css/swiper.min.css&quot;&gt; &lt;!-- Demo styles --&gt; &lt;style&gt; html, body &#123; position: relative; height: 100%; &#125; body &#123; background: #eee; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14px; color: #000; margin: 0; padding: 0; &#125; .swiper-container &#123; width: 100%; height: 100%; &#125; .swiper-slide &#123; text-align: center; font-size: 18px; background: #fff; /* Center slide text vertically */ display: -webkit-box; display: -ms-flexbox; display: -webkit-flex; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center; justify-content: center; -webkit-box-align: center; -ms-flex-align: center; -webkit-align-items: center; align-items: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- Swiper --&gt;&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;!-- url1,url2,url3,url4 替换成网页地址，注意跨域问题--&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url1&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url2&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url3&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt; &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;url4&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- Swiper JS --&gt;&lt;script src=&quot;$&#123;ctx&#125;/static/swiper/js/swiper.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;ctx&#125;/static/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- Initialize Swiper --&gt;&lt;script var swiper = new Swiper(&apos;.swiper-container&apos;, &#123; loop: true, autoplay: &#123; delay: 10000//10秒切换一次 // stopOnLastSlide: false, // disableOnInteraction: true &#125;, //开启循环 speed: 2000, // 如果需要前进后退按钮 navigation: &#123; nextEl: &apos;.swiper-button-next&apos;, prevEl: &apos;.swiper-button-prev&apos; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"html","slug":"html","permalink":"http://me.oopcoder.cn/blog/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://me.oopcoder.cn/blog/tags/html/"},{"name":"iframe","slug":"iframe","permalink":"http://me.oopcoder.cn/blog/tags/iframe/"},{"name":"banner","slug":"banner","permalink":"http://me.oopcoder.cn/blog/tags/banner/"},{"name":"swiper","slug":"swiper","permalink":"http://me.oopcoder.cn/blog/tags/swiper/"}]},{"title":"Linux命令行样式定制","slug":"linux-xshell-css","date":"2019-08-05T13:53:02.000Z","updated":"2019-08-09T08:33:13.447Z","comments":true,"path":"2019/08/05/linux-xshell-css/","link":"","permalink":"http://me.oopcoder.cn/2019/08/05/linux-xshell-css/","excerpt":"","text":"在使用linux命令行时候，总是难以区分命令和结果的具体界线，不知道当前的路径在哪里，就像下面这样，无形之中降低了我们的效率。但是我们在用git bash的时候不会有这个烦恼，那我们能不能将linux中的界面样式定制一下，变成git bash这样呢？答案是肯定的。 linux命令行界面 git bash 界面 通过查资料发现，要想修改命令行头部显示样式，实际的操作就是覆盖系统本身的 PS1 变量，如下代码所示，在当前用户(这里是root用户)的./bashrc中添加 PS1 的值就可以了 12345678910111213141516[root@VM_72_235_centos ~]# vi .bashrc[root@VM_72_235_centos ~]# cat .bashrc# .bashrc# User specific aliases and functionsalias rm=&apos;rm -i&apos;alias cp=&apos;cp -i&apos;alias mv=&apos;mv -i&apos;# Source global definitionsif [ -f /etc/bashrc ]; then . /etc/bashrcfi# 添加这行就可以了PS1=&apos;[\\[\\e[00;35m\\]\\u@dev \\t\\[\\e[0m\\]]\\[\\e[0;33m\\](\\w)\\$\\[\\e[0m\\] &apos;[root@VM_72_235_centos ~]# source .bashrc (执行这句设置生效，只对当前用户生效)[root@dev 22:36:51](~)# ls (发现生效了) 先将这行代码拆分如下，再来分析具体意思 12345 [ //表示【 [ 】 颜色为 默认颜色\\[\\e[00;35m\\] \\u@dev \\t //表示【 \\u@dev \\t 】 颜色为 【 \\[\\e[00;35m\\] 】\\[\\e[0m\\] ] //表示【 ] 】 颜色为 【 \\[\\e[0m\\] 】\\[\\e[0;33m\\] (\\w)\\$ //表示【 (\\w)\\$ 】 颜色为 【 \\[\\e[0;33m\\] 】\\[\\e[0m\\] //取消设置(设置回默认颜色) [\\e[00;35m] 该设置是应用到后面字符上，直到有其他设置，所以最后要设置回默认颜色 设置字符序列颜色的格式为：[\\e[F;Bm] 其中“F”为字体颜色，编号30 ~ 37；“B”为背景色，编号40 ~ 47 颜色表前景 | 背景 | 颜色—|—|—30 | 40 | 黑色31 | 41 | 红色32 | 42 | 绿色33 | 43 | 黄色34 | 44 | 蓝色35 | 45 | 紫红色36 | 46 | 青蓝色37 | 47 | 白色 变量值： \\d ：可显示出『星期 月 日』的日期格式，如：”Mon Feb 2” \\H ：完整的主机名称。举例来说，鸟哥的练习机为『www.vbird.tsai』 \\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略 \\t ：显示时间，为 24 小时格式的『HH:MM:SS』 \\T ：显示时间，为 12 小时格式的『HH:MM:SS』 \\A ：显示时间，为 24 小时格式的『HH:MM』 @ ：显示时间，为 12 小时格式的『am/pm』样式 \\u ：目前使用者的帐号名称，如『root』； \\v ：BASH 的版本资讯，如鸟哥的测试主机版本为 3.2.25(1)，仅取『3.2』显示 \\w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代； \\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。 # ：下达的第几个指令。 $ ：提示字元，如果是 root 时，提示字元为 # ，否则就是 $ \\n : new line,表示另起一行显示指令符 通过上面的颜色及变量值对照表，就可以轻松的定制出适合自己的样式啦。 我的配置如下，跟git bash相近 12345PS1=&apos;\\[\\e[00;35m\\]\\u@\\h \\t \\[\\e[0;33m\\]\\w (12.22.34.179)\\n\\$\\[\\e[0m\\] &apos; 效果如下(颜色在这里没显示出来)：root@VM_72_235_centos 21:22:43 /usr/local/share (12.22.34.179)$ less log.log 参考：在xshell中将命令行移至下一行: http://blog.sina.com.cn/s/blog_96a11ddf0102vbb7.html","categories":[{"name":"linux","slug":"linux","permalink":"http://me.oopcoder.cn/blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://me.oopcoder.cn/blog/tags/linux/"},{"name":"xshell","slug":"xshell","permalink":"http://me.oopcoder.cn/blog/tags/xshell/"}]},{"title":"为什么有时候maven无法更新jar包","slug":"maven-lastupdated","date":"2019-08-04T05:20:02.000Z","updated":"2019-08-05T01:24:58.327Z","comments":true,"path":"2019/08/04/maven-lastupdated/","link":"","permalink":"http://me.oopcoder.cn/2019/08/04/maven-lastupdated/","excerpt":"","text":"在使用maven管理pom项目的时候，多多少少会遇到一些奇葩的问题，比如网络良好，idea非离线状态，科学上网模式，maven就是死活无法更新jar包，很令人头大，无从下手找原因，当我们去查看maven本地仓库的时候，发现有些包里会多了一些以 .lastUpdated 结尾的文件，那么问题来了 为什么maven仓库会出现这些文件? 又会导致什么问题? 在idea网络状态很差或者离线状态时，需要从远程仓库下载某些jar包到本地参库时，因网络差，无法下载，导致本地仓库出现 xx.jar.lastUpdated 或者 xx.pom.lastUpdated 文件(文件具体作用暂时不清楚)， 由于这些文件的存在，即使网络变好后，项目仍然报错， 无法重新下载需要的jar包 解决方法: 方法非常简单粗暴，找到本地仓库对应jar包目录位置将 .lastUpdated 文件删除, 刷新项目重新下载即可 有的小伙伴可能会问，仓库那么多，总不会让我一个个找到然后删除吧，机智，下面给大家提供了两个一键删除脚本： 1、cleanLastUpdated.bat（windows版本）123456789rem 这里写你的仓库路径set REPOSITORY_PATH=D:\\Java\\maven-repositoryrem 正在搜索...for /f &quot;delims=&quot; %%i in (&apos;dir /b /s &quot;%REPOSITORY_PATH%\\*lastUpdated*&quot;&apos;) do ( echo %%i del /s /q &quot;%%i&quot;)rem 搜索完毕pause 2、cleanLastUpdated.sh（linux版本）12345# 这里写你的仓库路径REPOSITORY_PATH=~/Documents/tools/repositoryecho 正在搜索...find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; | xargs rm -frecho 搜索完 参考：maven仓库中的LastUpdated文件生成原因及删除","categories":[{"name":"maven","slug":"maven","permalink":"http://me.oopcoder.cn/blog/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://me.oopcoder.cn/blog/tags/maven/"},{"name":"pom","slug":"pom","permalink":"http://me.oopcoder.cn/blog/tags/pom/"}]},{"title":"Hexo 博客搭建（一）","slug":"hexo-blog-create","date":"2019-08-02T07:20:02.000Z","updated":"2019-08-05T01:24:58.326Z","comments":true,"path":"2019/08/02/hexo-blog-create/","link":"","permalink":"http://me.oopcoder.cn/2019/08/02/hexo-blog-create/","excerpt":"","text":"网上学习搭建hexo博客的教程一抓一大把，但是基本上都没说清楚这中间的原理到底是啥？那么让我带领大家一起去探个究竟，学习之前，我们先看看 Github Pages (以下简称 gp) 和 Hexo 到底是什么？ 1. 什么是Github Pages?官方文档是这样描述的： 1GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository. 好了，文档看完了，接下来可以愉快的创建一个属于自己的博客了，我先假设：你已经有了GitHub的账号，并且账号是 AAA， 首先 我们创建一个 名称为 AAA.github.io (名称必须按这个格式)的git仓库，如下图： 然后，在浏览器中输入 http://AAA.github.io 看到如上界面，说明我们的最简单的 github博客已经搭建完成啦~ 2. 什么是 Hexo?Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官方文档 点这查看 看到这里，可能还是一脸懵逼，不过我们需要知道 gp 和 hexo 之间的联系，在我看来, 他们之间其实没有任何关系，唯一的联系是： github 会托管静态网页，而 hexo 会生成静态网页，我们只是将hexo生成的网页放到 github上，这样访问 AAA.github.io 就访问了hexo生成的网页 这关系一下子就清楚了，接下来继续。。 3. 环境 Node.js / Git 安装来到这步，说明你已经了解了上述的概念 主要流程： 安装 git 安装 node node安装好之后，安装 hexo 安装细节的话，我们还是按照官方文档进行 坑：1.执行 npm install -g hexo-cli 长时间无响应，或者报如下错 1234567$ npm install -g hexo-clinpm ERR! code EAI_AGAINnpm ERR! errno EAI_AGAINnpm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: getaddrinfo EAI_AGAIN registry.npmjs.org:443npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\lanbing\\AppData\\Roaming\\npm-cache\\_logs\\2018-03-13T02_15_13_203Z-debug.log 解决办法：执行 $ npm install -g npm 更新 npm , 然后再次执行 $ npm install -g hexo-cli 1234567891011$ npm install -g npmC:\\Users\\lanbing\\AppData\\Roaming\\npm\\npm -&gt; C:\\Users\\lanbing\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.jsC:\\Users\\lanbing\\AppData\\Roaming\\npm\\npx -&gt; C:\\Users\\lanbing\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npx-cli.jsnpm@5.7.1added 533 packages in 113.185sC:\\Users\\lanbing\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\lanbing\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\bin\\hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\\hexo-cli\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)hexo-cli@1.1.0added 103 packages from 338 contributors in 73.08s 4.Hexo博客搭建踩过一系列的坑之后，现在终于可以开始搭建 hexo blog了 新建一个文件夹叫 helloBlog (可自己随便取名字，无所谓) 进入文件夹 helloBlog 中， 在 git bash 窗口里面执行下面命令初始化博客 12$ hexo init $ npm install //这条命令不执行，貌似也可以，不过官方文档写明要执行，那就执行吧 执行完命令后，文件夹目录如下表示初始化成功 12345678 .├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 博客已经构建好了，现在需要的是一个本地服务器来进行部署，Hexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用， 用如下命令安装： 1$ npm install hexo-server --save 现在启动服务器 12345$ hexo s //或者 hexo server// 出现如下信息，表明已经成功启动了服务器$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 现在在浏览器中输入 http://localhost:4000/或者 http://127.0.0.1:4000/（有的电脑，输入localhost访问不了，就用 127.0.0.1 访问）就可以访问啦~~ 到目前为止，我们知道了在怎么样利用 github 和 hexo 搭建博客, 但是要怎么实现上面说的，将 hexo 生成的静态博客网页，放到 github 中进行托管？就等下一篇文章再给大家讲解啦！！","categories":[{"name":"hexo","slug":"hexo","permalink":"http://me.oopcoder.cn/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://me.oopcoder.cn/blog/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-02T07:10:02.000Z","updated":"2019-08-05T01:24:58.324Z","comments":true,"path":"2019/08/02/hello-world/","link":"","permalink":"http://me.oopcoder.cn/2019/08/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}