<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring容器加载过程源码解析之默认标签解析</title>
      <link href="/2019/10/27/spring-resource-parse-default-element/"/>
      <url>/2019/10/27/spring-resource-parse-default-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在上文 <a href="https://me.oopcoder.cn/2019/10/21/spring-resource-parse/">Spring容器加载过程源码解析之Resource解析流程</a> 中，我们已经了解了整个解析流程，今天我们来具体分析下默认标签的解析。</p></blockquote><blockquote><p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p></blockquote><h5 id="1-什么是默认标签和自定义标签"><a href="#1-什么是默认标签和自定义标签" class="headerlink" title="1.什么是默认标签和自定义标签"></a>1.什么是默认标签和自定义标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // 判断是否为默认命名空间下的标签</span><br><span class="line">    if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123;</span><br><span class="line">        // 循环遍历 解析默认标签</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            if (node instanceof Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                String namespaceUri = delegate.getNamespaceURI(ele);</span><br><span class="line">                // 判断是否为默认命名空间下的标签</span><br><span class="line">                if (delegate.isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">                    // 默认标签解析方法</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 自定义标签解析方法</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 自定义标签解析方法</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断是否为默认命名空间下的标签</span><br><span class="line">public boolean isDefaultNamespace(String namespaceUri) &#123;</span><br><span class="line">return (!StringUtils.hasLength(namespaceUri) || &quot;http://www.springframework.org/schema/beans&quot;.equals(namespaceUri));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        // 解析 import 标签</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        // 解析 alias 标签</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        // 解析 bean 标签</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>isDefaultNamespace()</code> 方法可以看出，在命名空间 <code>http://www.springframework.org/schema/beans</code> 下面定义的标签就是我们所说的默认标签，比如顶级标签 <code>beans</code>, 以及下面的 <code>bean</code>,<code>import</code>,<code>alias</code>等等其他标签。</p><p>而不在默认命名空间下的标签就是自定义标签了，比如我们最常见的带 <code>context</code> 前缀的标签：<code>&lt;context:annotation-config/&gt;</code>,<code>&lt;context:component-scan base-package=&quot;com.xx.xx&quot;/&gt;</code>等。</p><h5 id="2-bean-标签解析方法-processBeanDefinition"><a href="#2-bean-标签解析方法-processBeanDefinition" class="headerlink" title="2.bean 标签解析方法 processBeanDefinition"></a>2.bean 标签解析方法 processBeanDefinition</h5><p>委托给了<code>BeanDefinitionParserDelegate#parseBeanDefinitionElement</code>进行解析，解析完成后再进行注册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // bean标签比较复杂，委托给了BeanDefinitionParserDelegate进行解析，返回封装了含 BeanDefinition，beanName，aliases 的BeanDefinitionHolder</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    if (bdHolder != null) &#123;</span><br><span class="line">        // 解析自定义属性或标签</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        try &#123;</span><br><span class="line">            // Register the final decorated instance.</span><br><span class="line">            // 注册到 BeanDefinitionRegistry，也就是DefaultListableBeanFactory中的 beanDefinitionMap 中</span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;catch (BeanDefinitionStoreException ex) &#123;&#125;</span><br><span class="line">        // Send registration event. 发送bean注册事件</span><br><span class="line">        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下看看代理类 <code>BeanDefinitionParserDelegate</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    // beans 标签下的 bean, containingBean 为空</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">    // 获取属性 id 值，用作 beanName</span><br><span class="line">    String id = ele.getAttribute(&quot;id&quot;);</span><br><span class="line">    // 获取属性 name 值，用作别名, 多个别名可用‘，’或‘；’分割开来</span><br><span class="line">    String nameAttr = ele.getAttribute(&quot;name&quot;);</span><br><span class="line">    // 分割多个别名</span><br><span class="line">    List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class="line">    if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    // 属性id值作为 bean 的名称</span><br><span class="line">    String beanName = id;</span><br><span class="line">    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        // 如果未定义id, 则将 第一个别名作为 beanName</span><br><span class="line">        beanName = aliases.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">    // beans 标签下的bean, 需要检查beanName和aliases的在当前xml配置文件中的唯一性</span><br><span class="line">    // bean 标签中嵌套的 bean 不需要检查</span><br><span class="line">    if (containingBean == null) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    // 解析标签的具体操作</span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    if (beanDefinition != null) &#123;</span><br><span class="line">        // 下面主要是没有定义 beanName 时，名字自动生成的逻辑</span><br><span class="line">        if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (containingBean != null) &#123;</span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                            beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"></span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    if (beanClassName != null &amp;&amp;</span><br><span class="line">                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //..........此处省略部分源码</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        // 返回 holder</span><br><span class="line">        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这部分主要是处理名字和别名的逻辑，下面看下解析的具体操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">        Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line">    this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = null;</span><br><span class="line">    // 解析 class 属性</span><br><span class="line">    if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        String parent = null;</span><br><span class="line">        // 解析 parent 属性</span><br><span class="line">        if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建GenericBeanDefinition实例</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">        // 解析其他属性 </span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">        // 解析meta标签</span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        // 解析lookup-method标签</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        // 解析replaced-method标签</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        // 解析constructor-arg标签</span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        // 解析property标签</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        // 解析qualifier标签</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(this.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line">        return bd;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    finally &#123;</span><br><span class="line">        this.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是解析的具体过程了，更具体的解析细节比较繁琐，不过逻辑简单，这里就不一一贴出来了，小伙伴们可以自己跟进去看看。</p><h5 id="3-import-标签解析方法-importBeanDefinitionResource"><a href="#3-import-标签解析方法-importBeanDefinitionResource" class="headerlink" title="3.import 标签解析方法 importBeanDefinitionResource"></a>3.import 标签解析方法 importBeanDefinitionResource</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void importBeanDefinitionResource(Element ele) &#123;</span><br><span class="line">    String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">    if (!StringUtils.hasText(location)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Resolve system properties: e.g. &quot;$&#123;user.dir&#125;&quot;</span><br><span class="line">    // 解析占位符</span><br><span class="line">    location = SystemPropertyUtils.resolvePlaceholders(location);</span><br><span class="line">    Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;Resource&gt;(4);</span><br><span class="line">    // 判断是绝对还是相对路径</span><br><span class="line">    boolean absoluteLocation = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">    &#125; catch (URISyntaxException ex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Absolute or relative?</span><br><span class="line">    if (absoluteLocation) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 确定是绝对路径后，直接交给 XmlBeanDefinitionReader 进行定位，加载，解析</span><br><span class="line">            int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">        &#125; catch (BeanDefinitionStoreException ex) &#123;&#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int importCount;</span><br><span class="line">            // 创建与当前资源同一父路径的相对资源</span><br><span class="line">            Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line">            if (relativeResource.exists()) &#123;</span><br><span class="line">                // 资源存在，直接加载</span><br><span class="line">                importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">                actualResources.add(relativeResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 资源不存在，表明路径是含有通配符的路径</span><br><span class="line">                String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">                importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                        StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //..........此处省略部分源码</span><br><span class="line">    &#125;</span><br><span class="line">    Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);</span><br><span class="line">    // 发送import事件</span><br><span class="line">    getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>import</code>标签解析比较简单，上面提到的资源 定位，加载方法: <code>loadBeanDefinitions</code>, 在<a href="https://me.oopcoder.cn/2019/10/18/spring-resource-load/">Spring容器加载过程源码解析之Resource定位加载</a>一文中有详细分析，想了解的小伙伴可以进去看看。</p><h5 id="4-alias-标签解析方法-processAliasRegistration"><a href="#4-alias-标签解析方法-processAliasRegistration" class="headerlink" title="4.alias 标签解析方法 processAliasRegistration"></a>4.alias 标签解析方法 processAliasRegistration</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void processAliasRegistration(Element ele) &#123;</span><br><span class="line">    String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">    boolean valid = true;</span><br><span class="line">    if (!StringUtils.hasText(name)) &#123;</span><br><span class="line">        valid = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">        valid = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 注册别名</span><br><span class="line">            getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">        &#125; catch (Exception ex) &#123;&#125;</span><br><span class="line">        // 发送alias注册事件</span><br><span class="line">        getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alias</code>标签跟<code>bean</code>标签下的<code>alias</code>属性都一样是<code>bean</code>的别名，那有什么作用呢？最简单的例子，比如，配置文件存在第三方<code>jar</code>包中，我们无法修改，但是又想通过特定的别名进行访问，这时候alias标签就派上用场了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// jar包中配置</span><br><span class="line">&lt;bean id=&quot;hello&quot;  name=&quot;hello-alias-1, hello-alias-2&quot;  class=“com.xx.xx&quot;/&gt;</span><br><span class="line">// 自己的配置</span><br><span class="line">&lt;alias name=&quot;hello&quot; alias=&quot;hello-alias-3&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;hello&quot; alias=&quot;hello-alias-4&quot;/&gt;</span><br></pre></td></tr></table></figure><p>按照上面这么配置，<code>hello</code> 就有4个别名了。</p><p>好了，今天的默认标签解析就分析到这里了，下篇文章我们再分析自定义标签是如何解析的。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring容器加载过程源码解析之Resource解析流程</title>
      <link href="/2019/10/21/spring-resource-parse/"/>
      <url>/2019/10/21/spring-resource-parse/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在上文 <a href="https://me.oopcoder.cn/2019/10/18/spring-resource-load/">Spring容器加载过程源码解析之Resource定位加载</a> 中，我们已经将资源路径解析为Resource了，今天我们来分析下整个解析流程。</p></blockquote><blockquote><p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p></blockquote><h5 id="1-XmlBeanDefinitionReader-分析"><a href="#1-XmlBeanDefinitionReader-分析" class="headerlink" title="1. XmlBeanDefinitionReader 分析"></a>1. XmlBeanDefinitionReader 分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这里才是真正将 资源路径 解析为Resource的地方</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            // 开始解析</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            //..........此处省略部分源码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int loadBeanDefinitions(Resource[] resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">    int counter = 0;</span><br><span class="line">    for (Resource resource : resources) &#123;</span><br><span class="line">        // 遍历所有资源 进行解析</span><br><span class="line">        counter += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        try &#123;</span><br><span class="line">            InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">            if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            // 从Resource获取输入流进行解析</span><br><span class="line">            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">        throws BeanDefinitionStoreException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int validationMode = getValidationModeForResource(resource);</span><br><span class="line">        // 通过 documentLoader 将资源转换为 Document 对象</span><br><span class="line">        Document doc = this.documentLoader.loadDocument(</span><br><span class="line">                inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());</span><br><span class="line">        return registerBeanDefinitions(doc, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// EntityResolver 由 BeansDtdResolver 和 PluggableSchemaResolver 组成</span><br><span class="line">// 用来在 classpath 下搜寻 schema 和 DTD 文件</span><br><span class="line">protected EntityResolver getEntityResolver() &#123;</span><br><span class="line">    if (this.entityResolver == null) &#123;</span><br><span class="line">        // Determine default EntityResolver to use.</span><br><span class="line">        ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">        if (resourceLoader != null) &#123;</span><br><span class="line">            this.entityResolver = new ResourceEntityResolver(resourceLoader);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.entityResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    // Read document based on new BeanDefinitionDocumentReader SPI.</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    // 委托 BeanDefinitionDocumentReader 解析document</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected XmlReaderContext createReaderContext(Resource resource) &#123;</span><br><span class="line">    if (this.namespaceHandlerResolver == null) &#123;</span><br><span class="line">        // 创建默认命名空间处理解析器</span><br><span class="line">        this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    return new XmlReaderContext(resource, this.problemReporter, this.eventListener,</span><br><span class="line">            this.sourceExtractor, this, this.namespaceHandlerResolver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() &#123;</span><br><span class="line">    // 用来解析 META-INF/spring.handlers 目录下对应的处理器，自定义标签的时候也会使用到，我们后面会详细分析</span><br><span class="line">    return new DefaultNamespaceHandlerResolver(getResourceLoader().getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中，我们看到XmlBeanDefinitionReader完成了如下工作：</p><ol><li>由内部的<code>ResourceLoader</code>去获取所有符合条件的<code>Resource</code> (上文已重点分析过 <a href="https://me.oopcoder.cn/2019/10/18/spring-resource-load/">Spring容器加载过程之源码解析之Resource定位加载</a>)；</li><li>从<code>Resource</code>中获取流，转化为方便解析的<code>Document</code>对象；</li><li>委托<code>BeanDefinitionDocumentReader</code>来解析 <code>Document</code>，所以实际的bean注册工作也是由它来完成。</li></ol><h5 id="2-DefaultBeanDefinitionDocumentReader-分析"><a href="#2-DefaultBeanDefinitionDocumentReader-分析" class="headerlink" title="2. DefaultBeanDefinitionDocumentReader 分析"></a>2. DefaultBeanDefinitionDocumentReader 分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">    this.readerContext = readerContext;</span><br><span class="line">    // 获取根元素，这里一般就是 beans 标签</span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    // 创建解析bean的代理类</span><br><span class="line">    BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);</span><br><span class="line">    // 与下方的 postProcessXml 一样，在这里都没有实现，可用来扩展自定义标签</span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    // 解析根元素</span><br><span class="line">    parseBeanDefinitions(root, delegate);</span><br><span class="line">    postProcessXml(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) &#123;</span><br><span class="line">    BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">    // 初始化默认的设置，即 beans 标签的属性</span><br><span class="line">    // Initialize the default lazy-init, autowire, dependency check settings, init-method, destroy-method and merge settings</span><br><span class="line">    delegate.initDefaults(root);</span><br><span class="line">    return delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    // 判断是否为默认命名空间下的标签</span><br><span class="line">    if (delegate.isDefaultNamespace(delegate.getNamespaceURI(root))) &#123;</span><br><span class="line">        // 循环遍历 解析默认标签</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            if (node instanceof Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                String namespaceUri = delegate.getNamespaceURI(ele);</span><br><span class="line">                // 判断是否为默认命名空间下的标签</span><br><span class="line">                if (delegate.isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">                    // 默认标签解析方法</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 自定义标签解析方法</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 自定义标签解析方法</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        // 解析 import 标签</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        // 解析 alias 标签</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        // 解析 bean 标签</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到这里，<code>Resource</code> 解析的整个流程就清晰了许多，默认标签和自定义标签的具体解析我们将在后面的文章再来分析。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring容器加载过程源码解析之Resource定位加载</title>
      <link href="/2019/10/18/spring-resource-load/"/>
      <url>/2019/10/18/spring-resource-load/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在上文 <a href="https://me.oopcoder.cn/2019/10/12/spring-startup-java/">如何手动启动Spring容器</a> 中，我们知道了可以通过传入资源文件来启动容器，如果将<code>applicationContext.xml</code>替换为绝对路径就启动不了，报错。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//启动容器</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)</span><br><span class="line"></span><br><span class="line">//更换为绝对路径，启动失败</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">                &quot;E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">//报 FileNotFoundException：Caused by: java.io.FileNotFoundException: class path resource [E:/IDEA_workspace/SpringLearningDemo/spring-java/src/main/resources/applicationContext.xml] cannot be opened because it does not exist</span><br><span class="line"></span><br><span class="line">//使用 FileSystemXmlApplicationContext 正常启动</span><br><span class="line">ApplicationContext context = new FileSystemXmlApplicationContext(</span><br><span class="line">                &quot;E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml&quot;);</span><br><span class="line">        </span><br><span class="line">// 启动成功</span><br><span class="line">ApplicationContext context = new FileSystemXmlApplicationContext(</span><br><span class="line">                &quot;classpath:applicationContext.xml&quot;);</span><br><span class="line">// 启动成功           </span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">                &quot;file:E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>通过字面意思，可以看出<code>ClassPathXmlApplicationContext</code>, 传入的是classpath目录下的资源文件, <code>FileSystemXmlApplicationContext</code>, 传入的是文件系统下资源文件(即文件绝对路径), 我们在资源文件前面加上 classpath 或 file，启动试试，发现也都成功了，看来资源的定位没有上面说的那么简单，还跟资源路径前缀有关。</p></blockquote><blockquote><p>提醒：本文是基于Spring 3.0.0.RELEASE 版本进行讲解的，其他版本可能稍有差异，在贴源码的时候，部分不影响流程的代码也在本文省略了</p></blockquote><p>下面带着疑问来看看Spring资源到底是怎么定位和加载进来的。进入ClassPathXmlApplicationContext源码，按下面路径走, 找到getResources方法：</p><blockquote><p>refresh() -&gt; obtainFreshBeanFactory() -&gt; refreshBeanFactory() -&gt; loadBeanDefinitions(DefaultListableBeanFactory beanFactory)  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// AbstractXmlApplicationContext.java</span><br><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">    // 创建 XmlBeanDefinitionReader</span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    // 传入ResourceLoader</span><br><span class="line">    beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    if (configResources != null) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取容器启动时，传入的资源文件路径</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    if (configLocations != null) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AbstractBeanDefinitionReader.java</span><br><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">        // Resource pattern matching available.</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这里才是真正将 资源路径 解析为Resource的地方</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            //..........此处省略部分源码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，<code>AbstractXmlApplicationContext</code> 将<code>Bean</code>的装载任务委派给了<code>XmlBeanDefinitionReader</code>, 而<code>ResourceLoader</code>负责将<code>xml</code>解析为<code>Resource</code>。</p><p>先看看类结构图</p><p><img src="https://pic.superbed.cn/item/5da86a9b451253d1780df669.png" alt></p><p>从上面可以看到，Spring为了统一不同类型的资源访问，把所有资源都抽象成<code>Resource</code>接口, 屏蔽不同资源之间的差异，其实现了<code>InputStreamSource</code>, 这样所有<code>Resource</code>都可以通过<code>getInputStream()</code>获取<code>InputStream</code>。</p><p><img src="https://pic.superbed.cn/item/5da86eb4451253d1780e7ce3.png" alt></p><p>其中<code>资源定位路径 -&gt; Resource</code> 这个过程是由 <code>ResourceLoader</code> 这个类来完成的，我们暂且称之为: 资源定位器, 其默认实现是 <code>DefaultResourceLoader</code>。</p><p><code>ResourcePatternResolver</code> 继承自 <code>ResourceResolver</code> ，扩展了一个能通过<code>路径模式</code>匹配定位的方法： <code>Resource[] getResources(String locationPattern)</code>，其路径模式支持以  <code>classpath / classpath*</code> 或 URI协议名（例如 <code>http、file、jar:file</code>）为其前缀，还支持 <code>Ant风格</code> 的匹配模式。</p><p>看看 <code>ResourcePatternResolver</code> 的实现类 <code>PathMatchingResourcePatternResolver</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法创建的 DefaultResourceLoader</span><br><span class="line">private final ResourceLoader resourceLoader;</span><br><span class="line">// Ant风格 路径匹配器</span><br><span class="line">private PathMatcher pathMatcher = new AntPathMatcher();</span><br><span class="line"></span><br><span class="line">public Resource[] getResources(String locationPattern) throws IOException &#123;</span><br><span class="line">    if (locationPattern.startsWith(&quot;classpath*:&quot;)) &#123;</span><br><span class="line">        // &quot;classpath*:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式</span><br><span class="line">        if (getPathMatcher().isPattern(locationPattern.substring(&quot;classpath*:&quot;.length()))) &#123;</span><br><span class="line">            // eg: classpath*:a/b/applicationContext-*.xml</span><br><span class="line">            // 根据路径模式 查找所有匹配的资源</span><br><span class="line">            return findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // eg: classpath*:a/b/applicationContext-dao.xml 或 classpath*:a/b/</span><br><span class="line">            // 根据确定路径 在所有classpath中(包含所有jar包)查找资源</span><br><span class="line">            return findAllClassPathResources(locationPattern.substring(&quot;classpath*:&quot;.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 第一个 &quot;:&quot; 后的路径是否含有通配符 “*” 或 “?”，即是否为路径模式</span><br><span class="line">        int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1;</span><br><span class="line">        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">            // 根据路径模式 查找所有匹配的资源</span><br><span class="line">            return findPathMatchingResources(locationPattern);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 加载单个资源，后面再详细讲讲 getResource 这个方法</span><br><span class="line">            return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据路径模式 查找所有匹配的资源</span><br><span class="line">protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123;</span><br><span class="line">    // 获取到一个不含通配符的根目录，如 classpath*:a/b/*/applicationContext-*.xml 返回 classpath*:a/b/</span><br><span class="line">    String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">    // 返回 */applicationContext-*.xml</span><br><span class="line">    String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line">    // 递归调用getResources(), 获取的符合根目录的所有资源</span><br><span class="line">    Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">    Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(16);</span><br><span class="line">    // 遍历根目录资源，将匹配的资源添加到 result 中</span><br><span class="line">    for (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">        // jar:file:开头的为jar包资源</span><br><span class="line">        if (isJarResource(rootDirResource)) &#123;</span><br><span class="line">            result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));</span><br><span class="line">        &#125; else if (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirResource, subPattern, getPathMatcher()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他类型资源走这里</span><br><span class="line">            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toArray(new Resource[result.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    File rootDir = rootDirResource.getFile().getAbsoluteFile();</span><br><span class="line">    //..........此处省略部分源码</span><br><span class="line">    return doFindMatchingFileSystemResources(rootDir, subPattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Set&lt;Resource&gt; doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException &#123;</span><br><span class="line">    // retrieveMatchingFiles 流程比较长就不贴出来了，有兴趣的朋友可以debug进去看看</span><br><span class="line">    Set&lt;File&gt; matchingFiles = retrieveMatchingFiles(rootDir, subPattern);</span><br><span class="line">    Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(matchingFiles.size());</span><br><span class="line">    for (File file : matchingFiles) &#123;</span><br><span class="line">        // 符合条件的路径 此时就解析为Resource了</span><br><span class="line">        result.add(new FileSystemResource(file));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是<code>PathMatchingResourcePatternResolver</code>路径模式匹配的基本逻辑。加载单个资源的任务是委托给了构造方法里面创建的 <code>DefaultResourceLoader</code></p><p>DefaultResourceLoader 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Resource getResource(String location) &#123;</span><br><span class="line">    // 以 classpath: 开头的返回 ClassPathResource</span><br><span class="line">    if (location.startsWith(&quot;classpath:&quot;)) &#123;</span><br><span class="line">        return new ClassPathResource(location.substring(&quot;classpath:&quot;.length()), getClassLoader());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 能够解析为URL的返回 UrlResource</span><br><span class="line">            URL url = new URL(location);</span><br><span class="line">            return new UrlResource(url);</span><br><span class="line">        &#125; catch (MalformedURLException ex) &#123;</span><br><span class="line">            // 不能够解析为URL的 由getResourceByPath返回</span><br><span class="line">            return getResourceByPath(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Resource getResourceByPath(String path) &#123;</span><br><span class="line">    // 默认返回 ClassPathContextResource</span><br><span class="line">    return new ClassPathContextResource(path, getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的类结构图，我们看到 <code>FileSystemXmlApplicationContext</code> 和 <code>ClassPathXmlApplicationContext</code> 都是 <code>DefaultResourceLoader</code> 的子类，区别在于前者重写了 <code>getResourceByPath</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Resource getResourceByPath(String path) &#123;</span><br><span class="line">    if (path != null &amp;&amp; path.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">        path = path.substring(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return new FileSystemResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 不带前缀的 路径或者 自定义前缀 的路径能否定位成功，关键在于<code>getResourceByPath</code>方法了，回到文章开始 传入的路径:</p><p><code>applicationContext.xml</code> 和 <code>E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml</code></p><blockquote><p>走的是 DefaultResourceLoader 默认的 getResourceByPath方法，返回的classpath里面的资源，所以后者在ClassPathXmlApplicationContext里面是启动不了的，反之前者在FileSystemXmlApplicationContext也启动不了</p></blockquote><p><code>classpath:applicationContext.xml</code> 和 <code>file:E:\\IDEA_workspace\\SpringLearningDemo\\spring-java\\src\\main\\resources\\applicationContext.xml</code></p><blockquote><p>都带有前缀，所以跟getResourceByPath无关，也就是跟 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 无关，传入哪个Context都能启动成功</p></blockquote><p>总结起来, Spring的资源路径填写方式如下：</p><table><thead><tr><th>前缀</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>classpath:</td><td>classpath:a/c.xml</td><td>从classpath中加载，存在多个资源则返回最先加载的那个资源，易导致资源加载不进来的问题</td></tr><tr><td>classpath*:</td><td>classpath*:a/c.xml</td><td>从classpath中加载，返回全部符合条件的资源，需要遍历所有classpath, 因此加载效率低</td></tr><tr><td>file: 或 jar:file: 等URI协议名</td><td>file:d:\b\f.xml</td><td>作为URL进行加载</td></tr><tr><td>没有前缀</td><td>a/c.xml 或 d:\b\f.xml</td><td>根据context的getResourceByPath方法判断</td></tr></tbody></table><p> Ant风格 的匹配模式</p><blockquote><p> “ ? ”：匹配一个字符, 如 a?.xml 匹配 ab.xml</p></blockquote><blockquote><p> “ * ”：匹配零个或多个字符串，如“a/ * /c.xml”将匹配“a/b/c.xml”，但不匹配匹配“a/c.xml”；而“a/c-*.xml”将匹配“a/c-dao.xml”</p></blockquote><blockquote><p>“ ** ”：匹配路径中的零个或多个目录，如“a/ ** /c.xml”将匹配“a /c.xml”，也匹配“a/b/b/c.xml”；而“a/b/c- ** .xml”将匹配“a/b/c-dao.xml”，即把“ ** ”当做两个“ * ”处理。</p></blockquote><p> 这就是Spring容器中资源的定位，然后通过 <code>Resource</code> 的 <code>getInputStream()</code> 加载进内存进行解析，至于如何解析，就请听下回分解啦。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何手动启动Spring容器</title>
      <link href="/2019/10/12/spring-startup-java/"/>
      <url>/2019/10/12/spring-startup-java/</url>
      
        <content type="html"><![CDATA[<p>工作中，我想大家最熟悉的Spring容器启动方法，就是在web环境下，通过在web.xml中配置如下代码进行启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">   &lt;param-value&gt;classpath*:/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><p>那么，离开了web环境，想单独的启动一个Spring容器该怎么做呢，其实也很简单，有两种方式，直接看代码：</p><h3 id="1-手动启动"><a href="#1-手动启动" class="headerlink" title="1. 手动启动"></a>1. 手动启动</h3><p>目录结构：</p><p><img src="https://pic.superbed.cn/item/5da1f344451253d178e6a6c6.png" alt></p><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;3.0.0.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 日志依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0.13&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 单元测试依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- spring单元测试依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>applicationContext.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld-id&quot; name=&quot;helloWorld&quot; class=&quot;com.bing.lan.spring.HelloWorld&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>日志配置： logback.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration debug=&quot;true&quot;&gt;</span><br><span class="line">    &lt;contextName&gt;spring&lt;/contextName&gt;</span><br><span class="line">    &lt;property name=&quot;NORMAL_PATTERN&quot;</span><br><span class="line">              value=&quot; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level - %logger&#123;100&#125; - %msg%n&quot;/&gt;</span><br><span class="line">              </span><br><span class="line">    &lt;Appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;Layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;Pattern&gt;$&#123;NORMAL_PATTERN&#125;&lt;/Pattern&gt;</span><br><span class="line">        &lt;/Layout&gt;</span><br><span class="line">    &lt;/Appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ROOT level=&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;Appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/ROOT&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure><p>HelloWorld.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">    private String name = &quot;OOPcoder&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HelloWorld&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringStartup.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.bing.lan.spring;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class SpringStartup &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 手动启动spring容器</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        </span><br><span class="line">        HelloWorld helloWorld = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        System.out.println(&quot;main(): &quot; + helloWorld);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动main函数，容器就启动了。</p><h3 id="2-通过-junit-来启动"><a href="#2-通过-junit-来启动" class="headerlink" title="2. 通过 junit 来启动"></a>2. 通过 junit 来启动</h3><p>在上面这些类的基础上再添加一个测试类</p><p>SpringTest.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.bing.lan.spring;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span><br><span class="line">public class SpringTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        HelloWorld helloWorld = (HelloWorld) applicationContext.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        System.out.println(&quot;main(): &quot; + helloWorld);</span><br><span class="line"></span><br><span class="line">        helloWorld = (HelloWorld) beanFactory.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        System.out.println(&quot;main(): &quot; + helloWorld);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行test()，容器启动成功。</p><p>学会了怎么启动，有啥好处呢，好处很多，比如</p><blockquote><ol><li><p>可以脱离web环境测试我们的 service / mapper 层，极大的提高开发效率；</p></li><li><p>还可以debug进Spring源码里学习各种原理，这对我们小白来说，是非常友好的，因为这只是一个单纯的Spring, 没有其他框架的干扰。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内嵌iframe实现html页面轮播</title>
      <link href="/2019/08/06/html-swiper-iframe/"/>
      <url>/2019/08/06/html-swiper-iframe/</url>
      
        <content type="html"><![CDATA[<p>需求是这样的，我们的产品要在某个展厅中展示，主办方要求我们提供部分系统界面在电视上作为宣传页，时间紧迫，已经来不及开发了，我就在想，能不能轮播我们系统已经存在的页面（哈哈，我是有多么懒），省心省力，想法虽好，但是作为一个前端白痴 ( 没怎么写过前端代码，轮播图都没实现过 )，对我来说还是有难度的啊~~ 但是没办法，自己提出来的想法，含着泪也得实现。</p><p>经过一天的查资料，终于实现了，实现后发现原来这么简单，下面把代码贴出来，鼓励自己继续学习前端。</p><blockquote><p>代码是jsp写的，用在html的话改改就可以了</p><p>轮播控件用的是 <a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">swiper</a> , 然后用iframe实现网页内嵌</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;</span><br><span class="line">&lt;%@page import=&quot;java.util.Calendar&quot; %&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br><span class="line">&lt;c:set var=&quot;ctx&quot; value=&quot;$&#123;pageContext.request.contextPath&#125;&quot;/&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Swiper demo&lt;/title&gt;</span><br><span class="line">    &lt;!-- Link Swiper&apos;s CSS --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;ctx&#125;/static/swiper/css/swiper.min.css&quot;&gt;</span><br><span class="line">    &lt;!-- Demo styles --&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html, body &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        body &#123;</span><br><span class="line">            background: #eee;</span><br><span class="line">            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">            color: #000;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .swiper-container &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        .swiper-slide &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            font-size: 18px;</span><br><span class="line">            background: #fff;</span><br><span class="line"></span><br><span class="line">            /* Center slide text vertically */</span><br><span class="line">            display: -webkit-box;</span><br><span class="line">            display: -ms-flexbox;</span><br><span class="line">            display: -webkit-flex;</span><br><span class="line">            display: flex;</span><br><span class="line">            -webkit-box-pack: center;</span><br><span class="line">            -ms-flex-pack: center;</span><br><span class="line">            -webkit-justify-content: center;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            -webkit-box-align: center;</span><br><span class="line">            -ms-flex-align: center;</span><br><span class="line">            -webkit-align-items: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- Swiper --&gt;</span><br><span class="line">&lt;div class=&quot;swiper-container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;swiper-wrapper&quot;&gt;</span><br><span class="line">    &lt;!-- url1,url2,url3,url4 替换成网页地址，注意跨域问题--&gt;</span><br><span class="line">        &lt;div class=&quot;swiper-slide&quot;&gt;</span><br><span class="line">            &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;</span><br><span class="line">                    src=&quot;url1&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;swiper-slide&quot;&gt;</span><br><span class="line">            &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;</span><br><span class="line">                    src=&quot;url2&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;swiper-slide&quot;&gt;</span><br><span class="line">            &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;</span><br><span class="line">                    src=&quot;url3&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;swiper-slide&quot;&gt;</span><br><span class="line">            &lt;iframe height=&quot;100%&quot; width=&quot;100%&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;</span><br><span class="line">                    src=&quot;url4&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 如果需要导航按钮 --&gt;</span><br><span class="line">    &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Swiper JS --&gt;</span><br><span class="line">&lt;script src=&quot;$&#123;ctx&#125;/static/swiper/js/swiper.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;ctx&#125;/static/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Initialize Swiper --&gt;</span><br><span class="line">&lt;script</span><br><span class="line">    var swiper = new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">        loop: true,</span><br><span class="line">        autoplay: &#123;</span><br><span class="line">            delay: 10000//10秒切换一次</span><br><span class="line">            // stopOnLastSlide: false,</span><br><span class="line">            // disableOnInteraction: true</span><br><span class="line">        &#125;,</span><br><span class="line">        //开启循环</span><br><span class="line">        speed: 2000,</span><br><span class="line">        // 如果需要前进后退按钮</span><br><span class="line">        navigation: &#123;</span><br><span class="line">            nextEl: &apos;.swiper-button-next&apos;,</span><br><span class="line">            prevEl: &apos;.swiper-button-prev&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> iframe </tag>
            
            <tag> banner </tag>
            
            <tag> swiper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行样式定制</title>
      <link href="/2019/08/05/linux-xshell-css/"/>
      <url>/2019/08/05/linux-xshell-css/</url>
      
        <content type="html"><![CDATA[<p>在使用linux命令行时候，总是难以区分命令和结果的具体界线，不知道当前的路径在哪里，就像下面这样，无形之中降低了我们的效率。但是我们在用git bash的时候不会有这个烦恼，那我们能不能将linux中的界面样式定制一下，变成git bash这样呢？答案是肯定的。</p><p><img src="https://pic.superbed.cn/item/5d482648451253d1787e9953.png" alt></p><p>linux命令行界面</p><p><img src="https://pic3.superbed.cn/item/5d482765451253d1787ec84e.png" alt></p><p>git bash 界面</p><p>通过查资料发现，要想修改命令行头部显示样式，实际的操作就是覆盖系统本身的 PS1 变量，如下代码所示，在当前用户(这里是root用户)的./bashrc中添加 PS1 的值就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_72_235_centos ~]# vi .bashrc</span><br><span class="line">[root@VM_72_235_centos ~]# cat .bashrc</span><br><span class="line"># .bashrc</span><br><span class="line"># User specific aliases and functions</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias cp=&apos;cp -i&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line"># Source global definitions</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">. /etc/bashrc</span><br><span class="line">fi</span><br><span class="line"># 添加这行就可以了</span><br><span class="line">PS1=&apos;[\[\e[00;35m\]\u@dev \t\[\e[0m\]]\[\e[0;33m\](\w)\$\[\e[0m\] &apos;</span><br><span class="line"></span><br><span class="line">[root@VM_72_235_centos ~]# source .bashrc (执行这句设置生效，只对当前用户生效)</span><br><span class="line">[root@dev 22:36:51](~)# ls (发现生效了)</span><br></pre></td></tr></table></figure><p>先将这行代码拆分如下，再来分析具体意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                    [               //表示【 [ 】 颜色为 默认颜色</span><br><span class="line">\[\e[00;35m\]       \u@dev \t       //表示【 \u@dev \t 】 颜色为 【 \[\e[00;35m\] 】</span><br><span class="line">\[\e[0m\]           ]               //表示【 ] 】 颜色为 【 \[\e[0m\] 】</span><br><span class="line">\[\e[0;33m\]        (\w)\$          //表示【 (\w)\$ 】 颜色为 【 \[\e[0;33m\] 】</span><br><span class="line">\[\e[0m\]                           //取消设置(设置回默认颜色)</span><br></pre></td></tr></table></figure><blockquote><p>[\e[00;35m] 该设置是应用到后面字符上，直到有其他设置，所以最后要设置回默认颜色 </p></blockquote><blockquote><p>设置字符序列颜色的格式为：[\e[F;Bm] 其中“F”为字体颜色，编号30 ~ 37；“B”为背景色，编号40 ~ 47</p></blockquote><p>颜色表<br>前景 | 背景 | 颜色<br>—|—|—<br>30 | 40 | 黑色<br>31 | 41 | 红色<br>32 | 42 | 绿色<br>33 | 43 | 黄色<br>34 | 44 | 蓝色<br>35 | 45 | 紫红色<br>36 | 46 | 青蓝色<br>37 | 47 | 白色</p><p>变量值：</p><ul><li>\d ：可显示出『星期 月 日』的日期格式，如：”Mon Feb 2”</li><li>\H ：完整的主机名称。举例来说，鸟哥的练习机为『<a href="http://www.vbird.tsai』" target="_blank" rel="noopener">www.vbird.tsai』</a></li><li>\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略</li><li>\t ：显示时间，为 24 小时格式的『HH:MM:SS』</li><li>\T ：显示时间，为 12 小时格式的『HH:MM:SS』</li><li>\A ：显示时间，为 24 小时格式的『HH:MM』</li><li>@ ：显示时间，为 12 小时格式的『am/pm』样式</li><li>\u ：目前使用者的帐号名称，如『root』；</li><li>\v ：BASH 的版本资讯，如鸟哥的测试主机版本为 3.2.25(1)，仅取『3.2』显示</li><li>\w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；</li><li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。</li><li># ：下达的第几个指令。</li><li>$ ：提示字元，如果是 root 时，提示字元为 # ，否则就是 $ </li><li>\n : new line,表示另起一行显示指令符</li></ul><p>通过上面的颜色及变量值对照表，就可以轻松的定制出适合自己的样式啦。</p><p>我的配置如下，跟git bash相近</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS1=&apos;\[\e[00;35m\]\u@\h \t \[\e[0;33m\]\w (12.22.34.179)\n\$\[\e[0m\] &apos; </span><br><span class="line"></span><br><span class="line">效果如下(颜色在这里没显示出来)：</span><br><span class="line">root@VM_72_235_centos 21:22:43 /usr/local/share (12.22.34.179)</span><br><span class="line">$ less log.log</span><br></pre></td></tr></table></figure><p>参考：<a href="http://blog.sina.com.cn/s/blog_96a11ddf0102vbb7.html" target="_blank" rel="noopener">在xshell中将命令行移至下一行:  http://blog.sina.com.cn/s/blog_96a11ddf0102vbb7.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么有时候maven无法更新jar包</title>
      <link href="/2019/08/04/maven-lastupdated/"/>
      <url>/2019/08/04/maven-lastupdated/</url>
      
        <content type="html"><![CDATA[<p>在使用maven管理pom项目的时候，多多少少会遇到一些奇葩的问题，比如网络良好，idea非离线状态，科学上网模式，maven就是死活无法更新jar包，很令人头大，无从下手找原因，当我们去查看maven本地仓库的时候，发现有些包里会多了一些以 .lastUpdated 结尾的文件，那么问题来了</p><h4 id="为什么maven仓库会出现这些文件-又会导致什么问题"><a href="#为什么maven仓库会出现这些文件-又会导致什么问题" class="headerlink" title="为什么maven仓库会出现这些文件? 又会导致什么问题?"></a>为什么maven仓库会出现这些文件? 又会导致什么问题?</h4><blockquote><p>在idea网络状态很差或者离线状态时，需要从远程仓库下载某些jar包到本地参库时，因网络差，无法下载，导致本地仓库出现 <code>xx.jar.lastUpdated</code> 或者 <code>xx.pom.lastUpdated</code> 文件(文件具体作用暂时不清楚)， 由于这些文件的存在，即使网络变好后，项目仍然报错， 无法重新下载需要的jar包</p></blockquote><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><blockquote><p>方法非常简单粗暴，找到本地仓库对应jar包目录位置将 <code>.lastUpdated</code> 文件删除, 刷新项目重新下载即可</p></blockquote><p>有的小伙伴可能会问，仓库那么多，总不会让我一个个找到然后删除吧，机智，下面给大家提供了两个一键删除脚本： </p><h6 id="1、cleanLastUpdated-bat（windows版本）"><a href="#1、cleanLastUpdated-bat（windows版本）" class="headerlink" title="1、cleanLastUpdated.bat（windows版本）"></a>1、cleanLastUpdated.bat（windows版本）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rem 这里写你的仓库路径</span><br><span class="line">set REPOSITORY_PATH=D:\Java\maven-repository</span><br><span class="line">rem 正在搜索...</span><br><span class="line">for /f &quot;delims=&quot; %%i in (&apos;dir /b /s &quot;%REPOSITORY_PATH%\*lastUpdated*&quot;&apos;) do (</span><br><span class="line">    echo %%i</span><br><span class="line">    del /s /q &quot;%%i&quot;</span><br><span class="line">)</span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h6 id="2、cleanLastUpdated-sh（linux版本）"><a href="#2、cleanLastUpdated-sh（linux版本）" class="headerlink" title="2、cleanLastUpdated.sh（linux版本）"></a>2、cleanLastUpdated.sh（linux版本）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这里写你的仓库路径</span><br><span class="line">REPOSITORY_PATH=~/Documents/tools/repository</span><br><span class="line">echo 正在搜索...</span><br><span class="line">find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; | xargs rm -fr</span><br><span class="line">echo 搜索完</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/u011990675/article/details/80066897" target="_blank" rel="noopener">maven仓库中的LastUpdated文件生成原因及删除</a></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> pom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客搭建（一）</title>
      <link href="/2019/08/02/hexo-blog-create/"/>
      <url>/2019/08/02/hexo-blog-create/</url>
      
        <content type="html"><![CDATA[<p>网上学习搭建hexo博客的教程一抓一大把，但是基本上都没说清楚这中间的原理到底是啥？那么让我带领大家一起去探个究竟，学习之前，我们先看看 Github Pages (以下简称 gp) 和 Hexo 到底是什么？</p><h2 id="1-什么是Github-Pages"><a href="#1-什么是Github-Pages" class="headerlink" title="1. 什么是Github Pages?"></a>1. 什么是Github Pages?</h2><p><a href="https://help.github.com/articles/what-is-github-pages/" target="_blank" rel="noopener">官方文档</a>是这样描述的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository.</span><br></pre></td></tr></table></figure><p>好了，文档看完了，接下来可以愉快的创建一个属于自己的博客了，我先假设：你已经有了GitHub的账号，并且账号是 <code>AAA</code>，</p><p>首先 我们创建一个 名称为 <code>AAA.github.io</code> (名称必须按这个格式)的git仓库，如下图： </p><p><img src="https://pic.superbed.cn/item/5d3ba3b6451253d178bfc354.png" alt></p><p>然后，在浏览器中输入 <code>http://AAA.github.io</code> </p><p><img src="https://pic.superbed.cn/item/5d3ba45f451253d178bfc82f.png" alt></p><p>看到如上界面，说明我们的最简单的 github博客已经搭建完成啦<del>~</del></p><h2 id="2-什么是-Hexo"><a href="#2-什么是-Hexo" class="headerlink" title="2. 什么是 Hexo?"></a>2. 什么是 Hexo?</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>官方文档 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">点这查看</a></p><p>看到这里，可能还是一脸懵逼，不过我们需要知道 gp 和 hexo 之间的联系，在我看来, 他们之间其实没有任何关系，唯一的联系是：</p><blockquote><p>github 会托管静态网页，而 hexo 会生成静态网页，我们只是将hexo生成的网页放到 github上，这样访问 <code>AAA.github.io</code> 就访问了hexo生成的网页</p></blockquote><p>这关系一下子就清楚了，接下来继续。。</p><h2 id="3-环境-Node-js-Git-安装"><a href="#3-环境-Node-js-Git-安装" class="headerlink" title="3. 环境 Node.js / Git 安装"></a>3. 环境 <a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> / <a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a> 安装</h2><p>来到这步，说明你已经了解了上述的概念</p><p>主要流程：</p><ol><li>安装 git</li><li>安装 node</li><li>node安装好之后，安装 hexo</li></ol><p>安装细节的话，我们还是按照<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方文档</a>进行</p><h3 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h3><p>1.执行 npm install -g hexo-cli 长时间无响应，或者报如下错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">npm ERR! code EAI_AGAIN</span><br><span class="line">npm ERR! errno EAI_AGAIN</span><br><span class="line">npm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: getaddrinfo EAI_AGAIN registry.npmjs.org:443</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\lanbing\AppData\Roaming\npm-cache\_logs\2018-03-13T02_15_13_203Z-debug.log</span><br></pre></td></tr></table></figure><p>解决办法：执行  <code>$ npm install -g npm</code> 更新 npm ,  然后再次执行 <code>$ npm install -g hexo-cli</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g npm</span><br><span class="line">C:\Users\lanbing\AppData\Roaming\npm\npm -&gt; C:\Users\lanbing\AppData\Roaming\npm\node_modules\npm\bin\npm-cli.js</span><br><span class="line">C:\Users\lanbing\AppData\Roaming\npm\npx -&gt; C:\Users\lanbing\AppData\Roaming\npm\node_modules\npm\bin\npx-cli.js</span><br><span class="line">npm@5.7.1</span><br><span class="line">added 533 packages in 113.185s</span><br><span class="line"></span><br><span class="line">C:\Users\lanbing\AppData\Roaming\npm\hexo -&gt; C:\Users\lanbing\AppData\Roaming\npm\node_modules\hexo-cli\bin\hexo</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\hexo-cli\node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line">hexo-cli@1.1.0</span><br><span class="line">added 103 packages from 338 contributors in 73.08s</span><br></pre></td></tr></table></figure><h2 id="4-Hexo博客搭建"><a href="#4-Hexo博客搭建" class="headerlink" title="4.Hexo博客搭建"></a>4.Hexo博客搭建</h2><p>踩过一系列的坑之后，现在终于可以开始搭建 hexo blog了</p><ol><li><p>新建一个文件夹叫   <code>helloBlog</code> (可自己随便取名字，无所谓)</p></li><li><p>进入文件夹 <code>helloBlog</code> 中， 在 <code>git bash</code> 窗口里面执行下面命令初始化博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init </span><br><span class="line">$ npm install //这条命令不执行，貌似也可以，不过官方文档写明要执行，那就执行吧</span><br></pre></td></tr></table></figure></li><li><p>执行完命令后，文件夹目录如下表示初始化成功</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> .</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></li><li><p>博客已经构建好了，现在需要的是一个本地服务器来进行部署，Hexo 3.0 把服务器独立成了个别模块，必须先安装 <a href="https://github.com/hexojs/hexo-server" target="_blank" rel="noopener">hexo-server</a> 才能使用， 用如下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure></li><li><p>现在启动服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s  //或者 hexo server</span><br><span class="line">// 出现如下信息，表明已经成功启动了服务器</span><br><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></li><li><p>现在在浏览器中输入 <code>http://localhost:4000/</code>或者 <code>http://127.0.0.1:4000/</code>（有的电脑，输入localhost访问不了，就用 127.0.0.1 访问）就可以访问啦~~</p></li></ol><p>到目前为止，我们知道了在怎么样利用 github 和 hexo 搭建博客, 但是要怎么实现上面说的，将 hexo 生成的静态博客网页，放到 github 中进行托管？就等下一篇文章再给大家讲解啦！！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/02/hello-world/"/>
      <url>/2019/08/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
